# 记忆系统深度分析

## 1. 记忆系统架构设计

### 1.1 核心组件概览

Moltbot 的记忆系统位于 `src/memory/` 目录，是一个功能完整的语义记忆检索系统。

**核心文件结构：**

- **manager.ts** - 记忆索引管理器核心
- **embeddings.ts** - 嵌入向量提供者抽象层
- **embeddings-openai.ts** - OpenAI 嵌入实现
- **embeddings-gemini.ts** - Gemini 嵌入实现
- **batch-openai.ts** - OpenAI 批处理 API
- **batch-gemini.ts** - Gemini 批处理 API
- **manager-search.ts** - 搜索逻辑
- **hybrid.ts** - 混合搜索（向量+关键词）
- **internal.ts** - 内部工具函数
- **memory-schema.ts** - 数据库模式定义
- **sqlite-vec.ts** - SQLite 向量扩展加载器

### 1.2 架构分层

```
┌─────────────────────────────────────────────────────┐
│           Agent Tools Layer                         │
│  (memory_search, memory_get)                        │
└─────────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────────┐
│      MemoryIndexManager (manager.ts)                │
│  - 索引管理  - 同步控制  - 缓存管理                 │
└─────────────────────────────────────────────────────┘
                      ↓
┌──────────────────┬──────────────────┬───────────────┐
│  Embedding Layer │  Storage Layer   │  Search Layer │
│  (embeddings.ts) │  (SQLite)        │  (hybrid.ts)  │
└──────────────────┴──────────────────┴───────────────┘
         ↓                  ↓                  ↓
┌────────────────┐  ┌──────────────┐  ┌──────────────┐
│ OpenAI/Gemini  │  │ sqlite-vec   │  │ FTS5         │
│ Local (llama)  │  │ (向量索引)    │  │ (全文搜索)    │
└────────────────┘  └──────────────┘  └──────────────┘
```

### 1.3 设计模式

**单例缓存模式：**
```typescript
const INDEX_CACHE = new Map<string, MemoryIndexManager>();
```
每个 Agent + 工作空间 + 配置组合对应一个唯一的 `MemoryIndexManager` 实例。

**工厂模式：**
```typescript
export async function createEmbeddingProvider(
  options: EmbeddingProviderOptions
): Promise<EmbeddingProviderResult>
```
根据配置动态创建 OpenAI、Gemini 或本地嵌入提供者。

## 2. 记忆的存储和检索机制

### 2.1 数据存储结构

**SQLite 数据库模式：** `memory-schema.ts`

```sql
-- 元数据表
CREATE TABLE meta (
  key TEXT PRIMARY KEY,
  value TEXT NOT NULL
);

-- 文件表
CREATE TABLE files (
  path TEXT PRIMARY KEY,
  source TEXT NOT NULL DEFAULT 'memory',  -- 'memory' 或 'sessions'
  hash TEXT NOT NULL,
  mtime INTEGER NOT NULL,
  size INTEGER NOT NULL
);

-- 文本块表
CREATE TABLE chunks (
  id TEXT PRIMARY KEY,
  path TEXT NOT NULL,
  source TEXT NOT NULL DEFAULT 'memory',
  start_line INTEGER NOT NULL,
  end_line INTEGER NOT NULL,
  hash TEXT NOT NULL,
  model TEXT NOT NULL,
  text TEXT NOT NULL,
  embedding TEXT NOT NULL,  -- JSON 序列化的向量
  updated_at INTEGER NOT NULL
);

-- 嵌入缓存表
CREATE TABLE embedding_cache (
  provider TEXT NOT NULL,
  model TEXT NOT NULL,
  provider_key TEXT NOT NULL,
  hash TEXT NOT NULL,
  embedding TEXT NOT NULL,
  dims INTEGER,
  updated_at INTEGER NOT NULL,
  PRIMARY KEY (provider, model, provider_key, hash)
);

-- FTS5 全文搜索表
CREATE VIRTUAL TABLE chunks_fts USING fts5(
  text,
  id UNINDEXED,
  path UNINDEXED,
  source UNINDEXED,
  model UNINDEXED,
  start_line UNINDEXED,
  end_line UNINDEXED
);

-- sqlite-vec 向量表
CREATE VIRTUAL TABLE chunks_vec USING vec0(
  id TEXT PRIMARY KEY,
  embedding FLOAT[dimensions]
);
```

### 2.2 文本分块策略

**Markdown 分块算法：** `internal.ts`

```typescript
export function chunkMarkdown(
  content: string,
  chunking: { tokens: number; overlap: number }
): MemoryChunk[]
```

**分块逻辑：**
1. **Token 估算**：`tokens * 4` 字符作为最大块大小
2. **重叠窗口**：`overlap * 4` 字符的重叠区域
3. **行级分割**：按行分割，避免截断句子
4. **长行处理**：超长行会被分段处理
5. **哈希标识**：每个块生成 SHA-256 哈希

**默认配置：**
- `DEFAULT_CHUNK_TOKENS = 400`
- `DEFAULT_CHUNK_OVERLAP = 80`

### 2.3 索引同步机制

**多源索引：**
```typescript
type MemorySource = "memory" | "sessions";
```

**Memory 源：**
- `MEMORY.md` / `memory.md`（工作空间根目录）
- `memory/` 目录下的所有 `.md` 文件
- 配置的 `extraPaths` 额外路径

**Sessions 源（实验性功能）：**
- Agent 的会话转录文件
- 自动提取用户和助手的对话内容

**同步触发条件：**
1. 手动同步：`sync({ force: true })`
2. 文件监听：`chokidar` 监听文件变化（防抖 1.5 秒）
3. 搜索时同步：`sync.onSearch = true`
4. 会话启动：`sync.onSessionStart = true`
5. 定时同步：`sync.intervalMinutes` 配置
6. 会话增量：会话文件增长超过阈值

**增量索引优化：**
```typescript
const record = this.db
  .prepare(`SELECT hash FROM files WHERE path = ? AND source = ?`)
  .get(entry.path, "memory");
if (!needsFullReindex && record?.hash === entry.hash) {
  // 跳过未变化的文件
  return;
}
```

## 3. 向量索引和语义搜索

### 3.1 嵌入向量提供者

**多提供者支持：** `embeddings.ts`

```typescript
export type EmbeddingProviderOptions = {
  provider: "openai" | "local" | "gemini" | "auto";
  remote?: {
    baseUrl?: string;
    apiKey?: string;
    headers?: Record<string, string>;
  };
  model: string;
  fallback: "openai" | "gemini" | "local" | "none";
  local?: {
    modelPath?: string;
    modelCacheDir?: string;
  };
};
```

**OpenAI 实现：** `embeddings-openai.ts`
- 默认模型：`text-embedding-3-small`
- 默认 API：`https://api.openai.com/v1`
- 支持自定义 baseUrl 和 headers

**Gemini 实现：** `embeddings-gemini.ts`
- 默认模型：`gemini-embedding-001`
- 支持批处理 API

**本地实现：** `embeddings.ts`
- 使用 `node-llama-cpp` 库
- 默认模型：`embeddinggemma-300M-Q8_0.gguf`
- 懒加载，避免启动开销

**自动降级策略：**
```typescript
if (requestedProvider === "auto") {
  // 1. 尝试本地模型（如果已下载）
  // 2. 尝试 OpenAI
  // 3. 尝试 Gemini
  // 4. 失败
}
```

### 3.2 向量索引实现

**sqlite-vec 扩展：** `sqlite-vec.ts`

```typescript
export async function loadSqliteVecExtension(params: {
  db: DatabaseSync;
  extensionPath?: string;
}): Promise<{ ok: boolean; extensionPath?: string; error?: string }>
```

**向量表创建：**
```typescript
this.db.exec(
  `CREATE VIRTUAL TABLE IF NOT EXISTS ${VECTOR_TABLE} USING vec0(
    id TEXT PRIMARY KEY,
    embedding FLOAT[${dimensions}]
  )`
);
```

**向量存储格式：**
```typescript
const vectorToBlob = (embedding: number[]): Buffer =>
  Buffer.from(new Float32Array(embedding).buffer);
```

### 3.3 向量搜索算法

**余弦相似度搜索：** `manager-search.ts`

```typescript
export async function searchVector(params: {
  db: DatabaseSync;
  vectorTable: string;
  providerModel: string;
  queryVec: number[];
  limit: number;
}): Promise<SearchRowResult[]>
```

**SQL 查询（使用 sqlite-vec）：**
```sql
SELECT c.id, c.path, c.start_line, c.end_line, c.text,
       c.source,
       vec_distance_cosine(v.embedding, ?) AS dist
  FROM chunks_vec v
  JOIN chunks c ON c.id = v.id
 WHERE c.model = ? AND c.source IN (...)
 ORDER BY dist ASC
 LIMIT ?
```

**余弦相似度计算：** `internal.ts`
```typescript
export function cosineSimilarity(a: number[], b: number[]): number {
  if (a.length === 0 || b.length === 0) return 0;
  const len = Math.min(a.length, b.length);
  let dot = 0, normA = 0, normB = 0;
  for (let i = 0; i < len; i++) {
    const av = a[i] ?? 0;
    const bv = b[i] ?? 0;
    dot += av * bv;
    normA += av * av;
    normB += bv * bv;
  }
  if (normA === 0 || normB === 0) return 0;
  return dot / (Math.sqrt(normA) * Math.sqrt(normB));
}
```

### 3.4 混合搜索（Hybrid Search）

**向量 + 关键词融合：** `hybrid.ts`

```typescript
export function mergeHybridResults(params: {
  vector: HybridVectorResult[];
  keyword: HybridKeywordResult[];
  vectorWeight: number;
  textWeight: number;
}): Array<{ /* ... */ }>
```

**算法流程：**
1. 向量搜索：获取语义相似的候选结果
2. 关键词搜索：使用 FTS5 BM25 算法
3. 结果合并：按 ID 去重
4. 加权融合：`score = vectorWeight * vectorScore + textWeight * textScore`
5. 排序返回：按融合分数降序排列

**默认权重：**
- `vectorWeight = 0.7`（语义相似度占 70%）
- `textWeight = 0.3`（关键词匹配占 30%）

**FTS5 查询构建：**
```typescript
export function buildFtsQuery(raw: string): string | null {
  const tokens = raw
    .match(/[A-Za-z0-9_]+/g)
    ?.map((t) => t.trim())
    .filter(Boolean) ?? [];
  if (tokens.length === 0) return null;
  const quoted = tokens.map((t) => `"${t.replaceAll('"', "")}"`);
  return quoted.join(" AND ");
}
```

## 4. 记忆的持久化

### 4.1 嵌入缓存机制

**缓存表结构：**
```sql
CREATE TABLE embedding_cache (
  provider TEXT NOT NULL,
  model TEXT NOT NULL,
  provider_key TEXT NOT NULL,  -- 提供者配置指纹
  hash TEXT NOT NULL,           -- 文本内容哈希
  embedding TEXT NOT NULL,      -- JSON 序列化的向量
  dims INTEGER,
  updated_at INTEGER NOT NULL,
  PRIMARY KEY (provider, model, provider_key, hash)
);
```

**缓存加载：**
```typescript
private loadEmbeddingCache(hashes: string[]): Map<string, number[]> {
  // 批量查询（每批 400 个哈希）
  const batchSize = 400;
  for (let start = 0; start < unique.length; start += batchSize) {
    const batch = unique.slice(start, start + batchSize);
    // 查询并解析
  }
}
```

**缓存淘汰：**
```typescript
private pruneEmbeddingCacheIfNeeded(): void {
  const max = this.cache.maxEntries;
  if (!max || max <= 0) return;
  const count = /* 查询总数 */;
  if (count <= max) return;
  const excess = count - max;
  this.db.prepare(
    `DELETE FROM ${EMBEDDING_CACHE_TABLE}
     WHERE rowid IN (
       SELECT rowid FROM ${EMBEDDING_CACHE_TABLE}
       ORDER BY updated_at ASC
       LIMIT ?
     )`
  ).run(excess);
}
```
使用 LRU（Least Recently Used）策略。

### 4.2 批处理优化

**OpenAI 批处理 API：** `batch-openai.ts`

```typescript
export async function runOpenAiEmbeddingBatches(params: {
  openAi: OpenAiEmbeddingClient;
  agentId: string;
  requests: OpenAiBatchRequest[];  // 最多 50,000 个请求
  wait: boolean;                   // 是否等待完成
  pollIntervalMs: number;          // 轮询间隔（默认 2 秒）
  timeoutMs: number;               // 超时时间（默认 60 分钟）
  concurrency: number;             // 并发批次数（默认 2）
}): Promise<Map<string, number[]>>
```

**批处理流程：**
1. 分组：每批最多 50,000 个请求
2. 上传：将请求打包为 JSONL 文件上传
3. 提交：创建批处理任务
4. 轮询：定期检查任务状态
5. 下载：获取输出文件并解析结果
6. 错误处理：读取错误文件并抛出详细错误

**批处理优势：**
- 成本降低：OpenAI 批处理 API 价格为标准 API 的 50%
- 速率限制：避免触发 API 速率限制
- 并发控制：支持多批次并发处理

## 5. 记忆与 Agent 的集成

### 5.1 Agent 工具接口

**memory_search 工具：** `src/agents/tools/memory-tool.ts`

```typescript
export function createMemorySearchTool(options: {
  config?: MoltbotConfig;
  agentSessionKey?: string;
}): AnyAgentTool | null {
  return {
    label: "Memory Search",
    name: "memory_search",
    description:
      "Mandatory recall step: semantically search MEMORY.md + memory/*.md " +
      "(and optional session transcripts) before answering questions about " +
      "prior work, decisions, dates, people, preferences, or todos; " +
      "returns top snippets with path + lines.",
    parameters: MemorySearchSchema,
    execute: async (_toolCallId, params) => {
      const query = readStringParam(params, "query", { required: true });
      const { manager } = await getMemorySearchManager({ cfg, agentId });
      const results = await manager.search(query, {
        maxResults,
        minScore,
        sessionKey: options.agentSessionKey,
      });
      return jsonResult({ results, provider, model, fallback });
    },
  };
}
```

**memory_get 工具：**

```typescript
export function createMemoryGetTool(options: {
  config?: MoltbotConfig;
  agentSessionKey?: string;
}): AnyAgentTool | null {
  return {
    label: "Memory Get",
    name: "memory_get",
    description:
      "Safe snippet read from MEMORY.md, memory/*.md, or configured " +
      "memorySearch.extraPaths with optional from/lines; use after " +
      "memory_search to pull only the needed lines and keep context small.",
    parameters: MemoryGetSchema,
    execute: async (_toolCallId, params) => {
      const relPath = readStringParam(params, "path", { required: true });
      const from = readNumberParam(params, "from", { integer: true });
      const lines = readNumberParam(params, "lines", { integer: true });
      const { manager } = await getMemorySearchManager({ cfg, agentId });
      const result = await manager.readFile({ relPath, from, lines });
      return jsonResult(result);
    },
  };
}
```

### 5.2 配置解析

**配置合并逻辑：** `memory-search.ts`

```typescript
function mergeConfig(
  defaults: MemorySearchConfig | undefined,
  overrides: MemorySearchConfig | undefined,
  agentId: string
): ResolvedMemorySearchConfig {
  // 1. 合并 enabled、provider、model 等基础配置
  // 2. 合并 remote（baseUrl、apiKey、headers、batch）
  // 3. 合并 local（modelPath、modelCacheDir）
  // 4. 合并 store（path、vector）
  // 5. 合并 chunking（tokens、overlap）
  // 6. 合并 sync（onSessionStart、onSearch、watch、sessions）
  // 7. 合并 query（maxResults、minScore、hybrid）
  // 8. 合并 cache（enabled、maxEntries）
  // 9. 归一化和验证参数
  return { /* ... */ };
}
```

**配置优先级：**
1. Agent 特定配置 (`agents.list[].memorySearch`)
2. 全局默认配置 (`agents.defaults.memorySearch`)
3. 硬编码默认值

## 6. 关键文件索引

| 文件 | 说明 |
|------|------|
| `manager.ts` | 记忆索引管理器核心 |
| `embeddings.ts` | 嵌入向量提供者抽象层 |
| `embeddings-openai.ts` | OpenAI 嵌入实现 |
| `embeddings-gemini.ts` | Gemini 嵌入实现 |
| `batch-openai.ts` | OpenAI 批处理 API |
| `batch-gemini.ts` | Gemini 批处理 API |
| `manager-search.ts` | 搜索逻辑 |
| `hybrid.ts` | 混合搜索 |
| `internal.ts` | 内部工具函数 |
| `memory-schema.ts` | 数据库模式定义 |
| `sqlite-vec.ts` | SQLite 向量扩展加载器 |
| `src/agents/tools/memory-tool.ts` | Agent 工具接口 |
| `src/agents/memory-search.ts` | 配置解析 |

## 7. 架构特点总结

1. **多提供者支持** - OpenAI、Gemini、本地模型
2. **混合搜索** - 向量语义 + 关键词匹配
3. **增量索引** - 只处理变化的文件
4. **嵌入缓存** - 避免重复计算
5. **批处理优化** - 降低成本和速率限制
6. **会话集成** - 可选索引会话历史
7. **原子重索引** - 安全的数据库更新

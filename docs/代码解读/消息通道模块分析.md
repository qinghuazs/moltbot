# 消息通道模块深度分析

## 1. 通道抽象层设计

### 1.1 核心架构

Moltbot 采用**插件化通道架构**，通过统一的抽象层支持多种消息平台。

**通道注册表：** `src/channels/registry.ts`

```typescript
export const CHAT_CHANNEL_ORDER = [
  "telegram", "whatsapp", "discord", "googlechat",
  "slack", "signal", "imessage"
] as const;
```

**通道插件接口：** `src/channels/plugins/types.plugin.ts`

```typescript
export type ChannelPlugin<ResolvedAccount = any> = {
  id: ChannelId;
  meta: ChannelMeta;                    // 通道元数据
  capabilities: ChannelCapabilities;     // 功能支持
  config: ChannelConfigAdapter;          // 配置管理
  security?: ChannelSecurityAdapter;     // 安全策略
  outbound?: ChannelOutboundAdapter;     // 消息发送
  gateway?: ChannelGatewayAdapter;       // 网关启动/停止
  pairing?: ChannelPairingAdapter;       // 配对认证
  // ... 更多适配器
};
```

### 1.2 适配器模式

每个通道通过多个适配器实现不同功能：

**核心适配器类型：** `src/channels/plugins/types.adapters.ts`

- `ChannelConfigAdapter`: 账户配置管理
- `ChannelOutboundAdapter`: 消息发送
- `ChannelGatewayAdapter`: 网关生命周期
- `ChannelSecurityAdapter`: 安全策略
- `ChannelDirectoryAdapter`: 联系人/群组目录
- `ChannelThreadingAdapter`: 线程/回复模式
- `ChannelMessageActionAdapter`: 消息操作

## 2. 各通道具体实现

### 2.1 Telegram 实现

**插件定义：** `extensions/telegram/src/channel.ts`

**关键特性：**
- **Bot API 集成**: 使用 grammY 框架
- **轮询模式**: grammyjs/runner 并发处理更新
- **Webhook 支持**: 可选 webhook 模式
- **消息格式化**: Markdown → Telegram HTML
- **线程支持**: Forum topics + 回复线程

**消息发送流程：** `src/telegram/send.ts`

```typescript
export async function sendMessageTelegram(
  to: string,
  text: string,
  opts: TelegramSendOpts = {}
): Promise<TelegramSendResult> {
  const cfg = loadConfig();
  const account = resolveTelegramAccount({ cfg, accountId: opts.accountId });
  const token = resolveToken(opts.token, account);
  const chatId = normalizeChatId(target.chatId);
  const api = opts.api ?? new Bot(token, client).api;
  // 支持媒体、按钮、线程等
}
```

**监控器启动：** `src/telegram/monitor.ts`

```typescript
export async function monitorTelegramProvider(opts) {
  const bot = createTelegramBot({ token, config, accountId });

  if (opts.useWebhook) {
    await startTelegramWebhook({ ... });
  } else {
    // 轮询模式，带自动重连
    const runner = run(bot, createTelegramRunnerOptions(cfg));
    await runner.task();
  }
}
```

### 2.2 Discord 实现

**插件定义：** `extensions/discord/src/channel.ts`

**关键特性：**
- **Gateway WebSocket**: 实时事件流
- **线程支持**: 原生线程 + 论坛频道
- **流式响应**: 支持分块流式回复
- **权限管理**: 频道权限检查
- **Slash 命令**: 原生命令支持

**消息发送：** `src/discord/send.ts`
- 支持嵌入卡片、按钮、表情符号
- 自动创建线程
- 媒体附件处理

### 2.3 WhatsApp (Web) 实现

**架构特点：**
- **Web 协议**: 基于 whatsapp-web.js
- **QR 登录**: 扫码认证
- **会话持久化**: 本地会话存储

**自动回复监控：** `src/web/auto-reply.impl.ts`

```typescript
export { monitorWebChannel } from "./auto-reply/monitor.js";
export { runWebHeartbeatOnce } from "./auto-reply/heartbeat-runner.js";
```

### 2.4 Slack 实现

**插件定义：** `extensions/slack/src/channel.ts`

**关键特性：**
- **Socket Mode**: WebSocket 连接
- **线程回复**: 自动线程管理
- **Slash 命令**: 原生命令支持
- **Block Kit**: 富文本消息

### 2.5 Signal 实现

**插件定义：** `extensions/signal/src/channel.ts`

**关键特性：**
- **signal-cli 集成**: REST API 模式
- **SSE 事件流**: 服务器发送事件
- **端到端加密**: 原生支持

### 2.6 iMessage 实现

**插件定义：** `extensions/imessage/src/channel.ts`

**关键特性：**
- **macOS 集成**: 本地 Messages.app 数据库
- **SQLite 监控**: 数据库轮询
- **AppleScript 发送**: 系统脚本调用

## 3. 消息收发机制

### 3.1 入站消息流程

**统一处理流程：**
1. **监控器接收** → 各通道 `monitor.ts`
2. **消息规范化** → `src/channels/plugins/normalize/`
3. **路由解析** → `src/routing/resolve-route.ts`
4. **安全检查** → allowlist + pairing
5. **会话管理** → `src/channels/session.ts`
6. **Agent 处理** → 自动回复引擎

**路由解析：** `src/routing/resolve-route.ts`

```typescript
export function resolveAgentRoute(input: ResolveAgentRouteInput): ResolvedAgentRoute {
  const channel = normalizeToken(input.channel);
  const accountId = normalizeAccountId(input.accountId);
  const peer = input.peer ? { kind: input.peer.kind, id: normalizeId(input.peer.id) } : null;
  // 根据 binding 规则匹配 agent
}
```

### 3.2 出站消息流程

**发送适配器：** `src/channels/plugins/outbound/telegram.ts`

```typescript
export const telegramOutbound: ChannelOutboundAdapter = {
  deliveryMode: "direct",
  chunker: markdownToTelegramHtmlChunks,
  textChunkLimit: 4000,
  sendText: async ({ to, text, accountId, replyToId, threadId }) => {
    const result = await sendMessageTelegram(to, text, { ... });
    return { channel: "telegram", ...result };
  },
  sendMedia: async ({ to, text, mediaUrl, ... }) => { ... },
  sendPayload: async ({ to, payload, ... }) => { ... }
};
```

**分块策略：**
- Telegram: 4000 字符 Markdown 分块
- Discord: 2000 字符限制
- WhatsApp: 自动分段

## 4. 认证与配置

### 4.1 账户管理

**多账户支持：** `src/telegram/accounts.ts`

```typescript
export function listTelegramAccountIds(cfg: MoltbotConfig): string[] {
  const ids = Array.from(
    new Set([...listConfiguredAccountIds(cfg), ...listBoundAccountIds(cfg, "telegram")])
  );
  if (ids.length === 0) return [DEFAULT_ACCOUNT_ID];
  return ids.sort((a, b) => a.localeCompare(b));
}

export function resolveTelegramAccount(params: {
  cfg: MoltbotConfig;
  accountId?: string | null;
}): ResolvedTelegramAccount {
  // 合并基础配置 + 账户配置
  // 解析 token (env/file/config)
  // 返回完整账户信息
}
```

### 4.2 配置适配器

**配置管理：** `src/channels/plugins/config-helpers.ts`

```typescript
export function setAccountEnabledInConfigSection(params: {
  cfg: MoltbotConfig;
  sectionKey: string;
  accountId: string;
  enabled: boolean;
}): MoltbotConfig {
  // 更新 channels.<channel>.accounts.<id>.enabled
}

export function deleteAccountFromConfigSection(params: {
  cfg: MoltbotConfig;
  sectionKey: string;
  accountId: string;
}): MoltbotConfig {
  // 删除账户配置
}
```

### 4.3 认证机制

**Pairing 系统：** `src/channels/plugins/pairing.ts`

```typescript
export async function notifyPairingApproved(params: {
  channelId: ChannelId;
  id: string;
  cfg: MoltbotConfig;
}): Promise<void> {
  const adapter = requirePairingAdapter(params.channelId);
  if (!adapter.notifyApproval) return;
  await adapter.notifyApproval({ cfg: params.cfg, id: params.id });
}
```

**安全策略：**
- **DM Policy**: `pairing` / `allowlist` / `open`
- **Group Policy**: `allowlist` / `open` + mention-gating
- **Allowlist 匹配**: `src/channels/allowlist-match.ts`

## 5. 通道间共享逻辑

### 5.1 Mention Gating

**提及检测：** `src/channels/mention-gating.ts`

```typescript
export function resolveMentionGating(params: MentionGateParams): MentionGateResult {
  const effectiveWasMentioned = params.wasMentioned || params.implicitMention || params.shouldBypassMention;
  const shouldSkip = params.requireMention && params.canDetectMention && !effectiveWasMentioned;
  return { effectiveWasMentioned, shouldSkip };
}
```

**应用场景：**
- 群组消息需要 @mention
- 控制命令可绕过
- 每个通道自定义提及模式

### 5.2 消息规范化

**目标规范化：** `src/channels/plugins/normalize/`

- `telegram.ts`: `telegram:<chatId>` 格式
- `whatsapp.ts`: `whatsapp:<jid>` 格式
- `discord.ts`: `discord:<channelId>` 格式
- `signal.ts`: `signal:<uuid>` 格式

### 5.3 消息操作

**统一操作接口：** `src/channels/plugins/message-actions.ts`

```typescript
export function listChannelMessageActions(cfg: MoltbotConfig): ChannelMessageActionName[] {
  const actions = new Set<ChannelMessageActionName>(["send", "broadcast"]);
  for (const plugin of listChannelPlugins()) {
    const list = plugin.actions?.listActions?.({ cfg });
    if (!list) continue;
    for (const action of list) actions.add(action);
  }
  return Array.from(actions);
}

export async function dispatchChannelMessageAction(
  ctx: ChannelMessageActionContext
): Promise<AgentToolResult<unknown> | null> {
  const plugin = getChannelPlugin(ctx.channel);
  if (!plugin?.actions?.handleAction) return null;
  return await plugin.actions.handleAction(ctx);
}
```

### 5.4 会话管理

**会话记录：** `src/channels/session.ts`

```typescript
export async function recordInboundSession(params: {
  storePath: string;
  sessionKey: string;
  ctx: MsgContext;
  updateLastRoute?: InboundLastRouteUpdate;
}): Promise<void> {
  // 记录会话元数据
  // 更新最后路由信息
  // 用于回复路由
}
```

### 5.5 插件发现与加载

**插件注册表：** `src/channels/plugins/index.ts`

```typescript
function listPluginChannels(): ChannelPlugin[] {
  const registry = requireActivePluginRegistry();
  return registry.channels.map((entry) => entry.plugin);
}

export function listChannelPlugins(): ChannelPlugin[] {
  const combined = dedupeChannels(listPluginChannels());
  return combined.sort((a, b) => {
    const orderA = a.meta.order ?? 999;
    const orderB = b.meta.order ?? 999;
    if (orderA !== orderB) return orderA - orderB;
    return a.id.localeCompare(b.id);
  });
}
```

## 6. 关键设计模式

### 6.1 适配器模式
每个通道实现统一接口，但内部实现完全独立。

### 6.2 插件架构
通道作为插件动态加载，支持扩展通道。

### 6.3 依赖注入
通过 `deps` 参数注入测试依赖，便于单元测试。

### 6.4 策略模式
安全策略、路由策略、线程策略可配置。

### 6.5 观察者模式
监控器订阅平台事件，转发到处理器。

## 7. 关键文件索引

### 核心抽象层

| 文件 | 说明 |
|------|------|
| `src/channels/registry.ts` | 通道注册表 |
| `src/channels/plugins/types.core.ts` | 核心类型定义 |
| `src/channels/plugins/types.plugin.ts` | 插件接口 |
| `src/channels/plugins/types.adapters.ts` | 适配器接口 |
| `src/channels/plugins/index.ts` | 插件加载器 |
| `src/channels/plugins/catalog.ts` | 插件目录 |

### 各通道实现

| 通道 | 插件定义 | 核心文件 |
|------|----------|----------|
| Telegram | `extensions/telegram/src/channel.ts` | `src/telegram/` |
| Discord | `extensions/discord/src/channel.ts` | `src/discord/` |
| WhatsApp | - | `src/web/` |
| Slack | `extensions/slack/src/channel.ts` | `src/slack/` |
| Signal | `extensions/signal/src/channel.ts` | `src/signal/` |
| iMessage | `extensions/imessage/src/channel.ts` | `src/imessage/` |

### 共享逻辑

| 文件 | 说明 |
|------|------|
| `src/routing/resolve-route.ts` | 路由解析 |
| `src/channels/mention-gating.ts` | 提及检测 |
| `src/channels/session.ts` | 会话管理 |
| `src/channels/plugins/pairing.ts` | 配对认证 |
| `src/channels/plugins/message-actions.ts` | 消息操作 |
| `src/channels/allowlist-match.ts` | Allowlist 匹配 |

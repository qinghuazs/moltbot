# 插件系统深度分析

## 1. 插件系统架构设计

### 1.1 核心架构概览

Moltbot 的插件系统采用了**模块化、可扩展的架构设计**，主要由以下几个核心组件构成：

```
src/plugins/
├── types.ts              # 类型定义（插件 API、钩子、配置等）
├── loader.ts             # 插件加载器
├── registry.ts           # 插件注册表
├── discovery.ts          # 插件发现机制
├── manifest.ts           # 插件清单管理
├── runtime.ts            # 运行时状态管理
├── runtime/              # 运行时实现
│   ├── index.ts         # 运行时 API 实现
│   └── types.ts         # 运行时类型定义
├── hooks.ts              # 钩子系统
├── tools.ts              # 工具注册
├── commands.ts           # 命令注册
└── services.ts           # 服务管理
```

### 1.2 架构特点

1. **分层设计**: 插件系统、核心系统、运行时环境三层分离
2. **依赖注入**: 通过 `PluginRuntime` 提供核心功能访问
3. **类型安全**: 完整的 TypeScript 类型定义
4. **热加载支持**: 支持插件的动态加载和卸载
5. **多来源支持**: 支持 bundled、global、workspace、config 四种插件来源

## 2. 插件加载和注册机制

### 2.1 插件发现流程

**文件：** `src/plugins/discovery.ts`

插件发现按以下优先级顺序扫描：

```typescript
export function discoverMoltbotPlugins(params: {
  workspaceDir?: string;
  extraPaths?: string[];
}): PluginDiscoveryResult {
  // 1. Config 路径 (最高优先级)
  for (const extraPath of extra) {
    discoverFromPath({ rawPath: trimmed, origin: "config", ... });
  }

  // 2. Workspace 扩展
  const workspaceExt = path.join(workspaceRoot, ".clawdbot", "extensions");
  discoverInDirectory({ dir: workspaceExt, origin: "workspace", ... });

  // 3. Global 扩展
  const globalDir = path.join(resolveConfigDir(), "extensions");
  discoverInDirectory({ dir: globalDir, origin: "global", ... });

  // 4. Bundled 插件
  const bundledDir = resolveBundledPluginsDir();
  discoverInDirectory({ dir: bundledDir, origin: "bundled", ... });
}
```

**插件识别规则：**
- 支持的文件扩展名: `.ts`, `.js`, `.mts`, `.cts`, `.mjs`, `.cjs`
- 目录结构: 支持 `index.ts/js` 或 `package.json` 中的 `moltbot.extensions` 字段
- 清单文件: `moltbot.plugin.json` 或 `clawdbot.plugin.json`

### 2.2 插件加载流程

**文件：** `src/plugins/loader.ts`

```typescript
export function loadMoltbotPlugins(options: PluginLoadOptions = {}): PluginRegistry {
  // 1. 规范化配置
  const normalized = normalizePluginsConfig(cfg.plugins);

  // 2. 检查缓存
  const cacheKey = buildCacheKey({ workspaceDir, plugins: normalized });
  if (cacheEnabled && cached) return cached;

  // 3. 清除旧命令
  clearPluginCommands();

  // 4. 创建注册表
  const { registry, createApi } = createPluginRegistry({ logger, runtime, ... });

  // 5. 发现插件候选
  const discovery = discoverMoltbotPlugins({ workspaceDir, extraPaths });

  // 6. 加载清单
  const manifestRegistry = loadPluginManifestRegistry({ config, candidates, ... });

  // 7. 使用 jiti 动态加载插件模块
  const jiti = createJiti(import.meta.url, {
    interopDefault: true,
    extensions: [".ts", ".tsx", ".mts", ...],
    alias: { "moltbot/plugin-sdk": pluginSdkAlias }
  });

  // 8. 遍历候选插件并注册
  for (const candidate of discovery.candidates) {
    // 验证启用状态、配置 schema、加载模块、调用 register
  }

  // 9. 缓存并激活
  registryCache.set(cacheKey, registry);
  setActivePluginRegistry(registry, cacheKey);
  initializeGlobalHookRunner(registry);

  return registry;
}
```

### 2.3 插件注册表

**文件：** `src/plugins/registry.ts`

```typescript
export type PluginRegistry = {
  plugins: PluginRecord[];           // 插件元数据
  tools: PluginToolRegistration[];   // 工具注册
  hooks: PluginHookRegistration[];   // 钩子注册
  typedHooks: TypedPluginHookRegistration[];  // 类型化钩子
  channels: PluginChannelRegistration[];      // 通道注册
  providers: PluginProviderRegistration[];    // 提供商注册
  gatewayHandlers: GatewayRequestHandlers;    // 网关处理器
  httpHandlers: PluginHttpRegistration[];     // HTTP 处理器
  httpRoutes: PluginHttpRouteRegistration[];  // HTTP 路由
  cliRegistrars: PluginCliRegistration[];     // CLI 注册器
  services: PluginServiceRegistration[];      // 服务注册
  commands: PluginCommandRegistration[];      // 命令注册
  diagnostics: PluginDiagnostic[];           // 诊断信息
};
```

## 3. 插件 SDK 提供的 API

### 3.1 核心 API 接口

**文件：** `src/plugins/types.ts`

```typescript
export type MoltbotPluginApi = {
  // 基本信息
  id: string;
  name: string;
  version?: string;
  description?: string;
  source: string;

  // 配置访问
  config: MoltbotConfig;
  pluginConfig?: Record<string, unknown>;

  // 运行时环境
  runtime: PluginRuntime;
  logger: PluginLogger;

  // 注册方法
  registerTool: (tool, opts?) => void;
  registerHook: (events, handler, opts?) => void;
  registerHttpHandler: (handler) => void;
  registerHttpRoute: (params) => void;
  registerChannel: (registration) => void;
  registerGatewayMethod: (method, handler) => void;
  registerCli: (registrar, opts?) => void;
  registerService: (service) => void;
  registerProvider: (provider) => void;
  registerCommand: (command) => void;

  // 工具方法
  resolvePath: (input: string) => string;
  on: <K extends PluginHookName>(hookName, handler, opts?) => void;
};
```

### 3.2 运行时 API (PluginRuntime)

**文件：** `src/plugins/runtime/types.ts`

运行时提供了丰富的核心功能访问：

```typescript
export type PluginRuntime = {
  version: string;

  // 配置管理
  config: {
    loadConfig: LoadConfig;
    writeConfigFile: WriteConfigFile;
  };

  // 系统功能
  system: {
    enqueueSystemEvent: EnqueueSystemEvent;
    runCommandWithTimeout: RunCommandWithTimeout;
    formatNativeDependencyHint: FormatNativeDependencyHint;
  };

  // 媒体处理
  media: {
    loadWebMedia, detectMime, mediaKindFromMime,
    isVoiceCompatibleAudio, getImageMetadata, resizeToJpeg
  };

  // TTS 功能
  tts: { textToSpeechTelephony };

  // 工具创建
  tools: {
    createMemoryGetTool, createMemorySearchTool, registerMemoryCli
  };

  // 通道功能
  channel: {
    text: { chunkByNewline, chunkMarkdownText, ... },
    reply: { dispatchReplyWithBufferedBlockDispatcher, ... },
    routing: { resolveAgentRoute },
    pairing: { buildPairingReply, ... },
    media: { fetchRemoteMedia, saveMediaBuffer },
    activity: { record, get },
    session: { resolveStorePath, ... },
    mentions: { buildMentionRegexes, ... },
    reactions: { shouldAckReaction, ... },
    groups: { resolveGroupPolicy, ... },
    debounce: { createInboundDebouncer, ... },
    commands: { resolveCommandAuthorizedFromAuthorizers, ... },

    // 各通道特定功能
    discord: { messageActions, auditChannelPermissions, ... },
    slack: { listDirectoryGroupsLive, ... },
    telegram: { auditGroupMembership, ... },
    signal: { probeSignal, ... },
    imessage: { monitorIMessageProvider, ... },
    whatsapp: { getActiveWebListener, ... },
    line: { listLineAccountIds, ... }
  };

  // 日志功能
  logging: {
    shouldLogVerbose, getChildLogger
  };

  // 状态管理
  state: { resolveStateDir };
};
```

### 3.3 插件定义结构

```typescript
export type MoltbotPluginDefinition = {
  id?: string;
  name?: string;
  description?: string;
  version?: string;
  kind?: PluginKind;  // "memory" 等
  configSchema?: MoltbotPluginConfigSchema;
  register?: (api: MoltbotPluginApi) => void | Promise<void>;
  activate?: (api: MoltbotPluginApi) => void | Promise<void>;
};
```

## 4. 插件与主程序的通信方式

### 4.1 工具 (Tools) 注册

**文件：** `src/plugins/tools.ts`

```typescript
export function resolvePluginTools(params: {
  context: MoltbotPluginToolContext;
  existingToolNames?: Set<string>;
  toolAllowlist?: string[];
}): AnyAgentTool[] {
  // 1. 加载插件注册表
  // 2. 遍历工具注册
  // 3. 调用工具工厂函数
  // 4. 处理可选工具的白名单过滤
  // 5. 检查名称冲突
  // 6. 添加到工具列表
}
```

### 4.2 钩子 (Hooks) 系统

**文件：** `src/plugins/hooks.ts`

钩子系统支持 13 种生命周期事件：

```typescript
export type PluginHookName =
  | "before_agent_start"      // Agent 启动前
  | "agent_end"               // Agent 结束
  | "before_compaction"       // 压缩前
  | "after_compaction"        // 压缩后
  | "message_received"        // 消息接收
  | "message_sending"         // 消息发送中
  | "message_sent"            // 消息已发送
  | "before_tool_call"        // 工具调用前
  | "after_tool_call"         // 工具调用后
  | "tool_result_persist"     // 工具结果持久化
  | "session_start"           // 会话开始
  | "session_end"             // 会话结束
  | "gateway_start"           // 网关启动
  | "gateway_stop";           // 网关停止
```

**钩子执行策略：**

```typescript
export function createHookRunner(registry: PluginRegistry, options: HookRunnerOptions = {}) {
  // 1. Void 钩子 - 并行执行，不返回值
  async function runVoidHook<K extends PluginHookName>(...) {
    const hooks = getHooksForName(registry, hookName);
    const promises = hooks.map(async (hook) => {
      await hook.handler(event, ctx);
    });
    await Promise.all(promises);  // 并行执行
  }

  // 2. Modifying 钩子 - 顺序执行，可修改数据
  async function runModifyingHook<K extends PluginHookName, TResult>(...) {
    const hooks = getHooksForName(registry, hookName);
    let result: TResult | undefined;

    for (const hook of hooks) {  // 顺序执行
      const handlerResult = await hook.handler(event, ctx);
      if (handlerResult !== undefined) {
        result = mergeResults ? mergeResults(result, handlerResult) : handlerResult;
      }
    }

    return result;
  }

  // 3. Sync 钩子 - 同步执行
  function runToolResultPersist(...) {
    // ...
  }
}
```

### 4.3 命令 (Commands) 注册

**文件：** `src/plugins/commands.ts`

插件可以注册自定义命令，绕过 LLM 处理：

```typescript
export type MoltbotPluginCommandDefinition = {
  name: string;                    // 命令名称（不含 /）
  description: string;             // 描述
  acceptsArgs?: boolean;           // 是否接受参数
  requireAuth?: boolean;           // 是否需要授权（默认 true）
  handler: PluginCommandHandler;   // 处理函数
};
```

### 4.4 服务 (Services) 管理

**文件：** `src/plugins/services.ts`

插件可以注册长期运行的后台服务：

```typescript
export async function startPluginServices(params: {
  registry: PluginRegistry;
  config: MoltbotConfig;
  workspaceDir?: string;
}): Promise<PluginServicesHandle> {
  const running: Array<{ id: string; stop?: () => void | Promise<void> }> = [];

  // 启动所有服务
  for (const entry of params.registry.services) {
    const service = entry.service;
    try {
      await service.start({
        config: params.config,
        workspaceDir: params.workspaceDir,
        stateDir: STATE_DIR,
        logger: { info, warn, error, debug }
      });
      running.push({ id: service.id, stop: service.stop });
    } catch (err) {
      log.error(`plugin service failed (${service.id}): ${String(err)}`);
    }
  }

  // 返回停止句柄
  return {
    stop: async () => {
      for (const entry of running.reverse()) {
        if (entry.stop) await entry.stop();
      }
    }
  };
}
```

## 5. 插件生命周期管理

### 5.1 生命周期阶段

```
1. 发现 (Discovery)
   ↓
2. 清单加载 (Manifest Loading)
   ↓
3. 配置验证 (Config Validation)
   ↓
4. 模块加载 (Module Loading)
   ↓
5. 注册 (Registration)
   ↓
6. 激活 (Activation)
   ↓
7. 运行 (Running)
   ↓
8. 停止 (Stopping)
```

### 5.2 插件状态

```typescript
export type PluginRecord = {
  id: string;
  name: string;
  version?: string;
  description?: string;
  kind?: PluginKind;
  source: string;
  origin: PluginOrigin;  // "bundled" | "global" | "workspace" | "config"
  workspaceDir?: string;
  enabled: boolean;
  status: "loaded" | "disabled" | "error";
  error?: string;
  // ... 其他元数据
};
```

### 5.3 插件启用/禁用逻辑

```typescript
export function resolveEnableState(
  pluginId: string,
  origin: PluginOrigin,
  config: NormalizedPluginsConfig
): { enabled: boolean; reason?: string } {
  // 1. 检查显式禁用
  if (config.disabled.has(pluginId)) {
    return { enabled: false, reason: "disabled in config" };
  }

  // 2. 检查白名单模式
  if (config.enabledOnly.size > 0 && !config.enabledOnly.has(pluginId)) {
    return { enabled: false, reason: "not in enabled list" };
  }

  // 3. 检查来源优先级
  if (origin === "bundled" && config.disableBundled) {
    return { enabled: false, reason: "bundled plugins disabled" };
  }

  return { enabled: true };
}
```

## 6. 实际插件示例

### 6.1 简单插件: memory-core

**文件：** `extensions/memory-core/index.ts`

```typescript
const memoryCorePlugin = {
  id: "memory-core",
  name: "Memory (Core)",
  description: "File-backed memory search tools and CLI",
  kind: "memory",
  configSchema: emptyPluginConfigSchema(),

  register(api: MoltbotPluginApi) {
    // 1. 注册工具
    api.registerTool(
      (ctx) => {
        const memorySearchTool = api.runtime.tools.createMemorySearchTool({
          config: ctx.config,
          agentSessionKey: ctx.sessionKey,
        });
        const memoryGetTool = api.runtime.tools.createMemoryGetTool({
          config: ctx.config,
          agentSessionKey: ctx.sessionKey,
        });
        return [memorySearchTool, memoryGetTool];
      },
      { names: ["memory_search", "memory_get"] }
    );

    // 2. 注册 CLI 命令
    api.registerCli(
      ({ program }) => {
        api.runtime.tools.registerMemoryCli(program);
      },
      { commands: ["memory"] }
    );
  },
};

export default memoryCorePlugin;
```

## 7. 关键设计模式

### 7.1 依赖注入模式

通过 `PluginRuntime` 提供核心功能，避免直接依赖：

```typescript
// 插件代码
api.runtime.channel.discord.sendMessageDiscord({ ... });
api.runtime.media.detectMime(buffer);
api.runtime.logging.getChildLogger({ plugin: "my-plugin" });
```

### 7.2 工厂模式

工具使用工厂函数创建，支持上下文相关的实例化：

```typescript
api.registerTool(
  (ctx: MoltbotPluginToolContext) => {
    // 根据上下文创建工具实例
    if (!ctx.sessionKey) return null;
    return createMyTool(ctx);
  },
  { names: ["my_tool"], optional: true }
);
```

### 7.3 错误隔离

单个插件的错误不会影响其他插件：

```typescript
try {
  const result = register(api);
  registry.plugins.push(record);
} catch (err) {
  logger.error(`plugin failed during register: ${String(err)}`);
  record.status = "error";
  record.error = String(err);
  registry.plugins.push(record);  // 仍然记录失败的插件
}
```

### 7.4 类型安全

完整的 TypeScript 类型定义确保编译时检查：

```typescript
// 类型化钩子
api.on("before_agent_start", async (event, ctx) => {
  // event 和 ctx 都有完整的类型推断
  return {
    systemPrompt: "Custom prompt",
    prependContext: "Additional context"
  };
});
```

## 8. 关键文件索引

| 文件 | 说明 |
|------|------|
| `types.ts` | 类型定义 |
| `loader.ts` | 插件加载器 |
| `registry.ts` | 插件注册表 |
| `discovery.ts` | 插件发现机制 |
| `manifest.ts` | 插件清单管理 |
| `runtime.ts` | 运行时状态管理 |
| `runtime/index.ts` | 运行时 API 实现 |
| `runtime/types.ts` | 运行时类型定义 |
| `hooks.ts` | 钩子系统 |
| `tools.ts` | 工具注册 |
| `commands.ts` | 命令注册 |
| `services.ts` | 服务管理 |

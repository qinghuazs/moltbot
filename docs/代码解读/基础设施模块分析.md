# 基础设施模块深度分析

## 1. 基础设施模块组成

`src/infra/` 目录是 Moltbot 项目的核心基础设施层，主要模块包括：

### 1.1 核心子目录
- **`net/`**: 网络安全模块（SSRF 防护）
- **`outbound/`**: 消息发送基础设施
- **`tls/`**: TLS/证书管理

### 1.2 关键功能模块
- 日志系统
- 错误处理
- 环境变量管理
- 文件系统操作
- 网络请求工具
- 设备认证与配对
- 网关锁机制
- 更新检查与自动更新
- 心跳监控
- 系统事件队列

## 2. 日志系统

### 2.1 核心架构

**主要文件**:
- `src/logging/logger.ts`
- `src/logging/subsystem.ts`

**日志存储路径**:
```typescript
export const DEFAULT_LOG_DIR = "/tmp/moltbot";
export const DEFAULT_LOG_FILE = path.join(DEFAULT_LOG_DIR, "moltbot.log");
```

### 2.2 日志滚动机制

**按日期滚动**:
```typescript
function defaultRollingPathForToday(): string {
  const today = formatLocalDate(new Date());
  return path.join(DEFAULT_LOG_DIR, `${LOG_PREFIX}-${today}${LOG_SUFFIX}`);
}
```

**自动清理旧日志**:
```typescript
const MAX_LOG_AGE_MS = 24 * 60 * 60 * 1000; // 24小时

function pruneOldRollingLogs(dir: string): void {
  const cutoff = Date.now() - MAX_LOG_AGE_MS;
  for (const entry of entries) {
    if (stat.mtimeMs < cutoff) {
      fs.rmSync(fullPath, { force: true });
    }
  }
}
```

### 2.3 子系统日志器

**创建子系统日志器**:
```typescript
export function createSubsystemLogger(subsystem: string): SubsystemLogger {
  const emit = (level: LogLevel, message: string, meta?: Record<string, unknown>) => {
    logToFile(getFileLogger(), level, message, fileMeta);
    if (shouldLogToConsole(level, { level: consoleSettings.level })) {
      const line = formatConsoleLine({ level, subsystem, message, style, meta });
      writeConsoleLine(level, line);
    }
  };

  return {
    subsystem,
    trace: (message, meta) => emit("trace", message, meta),
    debug: (message, meta) => emit("debug", message, meta),
    info: (message, meta) => emit("info", message, meta),
    warn: (message, meta) => emit("warn", message, meta),
    error: (message, meta) => emit("error", message, meta),
    fatal: (message, meta) => emit("fatal", message, meta),
    raw: (message) => { /* 直接输出 */ },
    child: (name) => createSubsystemLogger(`${subsystem}/${name}`),
  };
}
```

**日志格式化**:
```typescript
const SUBSYSTEM_COLORS = ["cyan", "green", "yellow", "blue", "magenta", "red"];

function pickSubsystemColor(color: ChalkInstance, subsystem: string): ChalkInstance {
  let hash = 0;
  for (let i = 0; i < subsystem.length; i += 1) {
    hash = (hash * 31 + subsystem.charCodeAt(i)) | 0;
  }
  const idx = Math.abs(hash) % SUBSYSTEM_COLORS.length;
  return color[SUBSYSTEM_COLORS[idx]];
}
```

## 3. 错误处理

### 3.1 错误工具函数

**文件**: `src/infra/errors.ts`

```typescript
export function extractErrorCode(err: unknown): string | undefined {
  if (!err || typeof err !== "object") return undefined;
  const code = (err as { code?: unknown }).code;
  if (typeof code === "string") return code;
  if (typeof code === "number") return String(code);
  return undefined;
}

export function formatErrorMessage(err: unknown): string {
  if (err instanceof Error) {
    return err.message || err.name || "Error";
  }
  if (typeof err === "string") return err;
  try {
    return JSON.stringify(err);
  } catch {
    return Object.prototype.toString.call(err);
  }
}
```

### 3.2 未处理的 Promise 拒绝

**文件**: `src/infra/unhandled-rejections.ts`

**致命错误代码**:
```typescript
const FATAL_ERROR_CODES = new Set([
  "ERR_OUT_OF_MEMORY",
  "ERR_SCRIPT_EXECUTION_TIMEOUT",
  "ERR_WORKER_OUT_OF_MEMORY",
  "ERR_WORKER_UNCAUGHT_EXCEPTION",
  "ERR_WORKER_INITIALIZATION_FAILED",
]);
```

**瞬态网络错误（不应崩溃）**:
```typescript
const TRANSIENT_NETWORK_CODES = new Set([
  "ECONNRESET", "ECONNREFUSED", "ENOTFOUND", "ETIMEDOUT",
  "ESOCKETTIMEDOUT", "ECONNABORTED", "EPIPE",
  "EHOSTUNREACH", "ENETUNREACH", "EAI_AGAIN",
  "UND_ERR_CONNECT_TIMEOUT", "UND_ERR_DNS_RESOLVE_FAILED",
  "UND_ERR_CONNECT", "UND_ERR_SOCKET",
  "UND_ERR_HEADERS_TIMEOUT", "UND_ERR_BODY_TIMEOUT",
]);
```

**AbortError 检测**:
```typescript
export function isAbortError(err: unknown): boolean {
  if (!err || typeof err !== "object") return false;
  const name = "name" in err ? String(err.name) : "";
  if (name === "AbortError") return true;
  const message = "message" in err && typeof err.message === "string" ? err.message : "";
  if (message === "This operation was aborted") return true;
  return false;
}
```

**全局处理器安装**:
```typescript
export function installUnhandledRejectionHandler(): void {
  process.on("unhandledRejection", (reason, _promise) => {
    if (isUnhandledRejectionHandled(reason)) return;

    if (isAbortError(reason)) {
      console.warn("[moltbot] Suppressed AbortError:", formatUncaughtError(reason));
      return;
    }

    if (isFatalError(reason)) {
      console.error("[moltbot] FATAL unhandled rejection:", formatUncaughtError(reason));
      process.exit(1);
    }

    if (isTransientNetworkError(reason)) {
      console.warn("[moltbot] Non-fatal unhandled rejection (continuing):", formatUncaughtError(reason));
      return;
    }

    console.error("[moltbot] Unhandled promise rejection:", formatUncaughtError(reason));
    process.exit(1);
  });
}
```

## 4. 环境变量管理

### 4.1 环境变量工具

**文件**: `src/infra/env.ts`

```typescript
export function logAcceptedEnvOption(option: AcceptedEnvOption): void {
  if (process.env.VITEST || process.env.NODE_ENV === "test") return;
  if (loggedEnv.has(option.key)) return;
  const rawValue = option.value ?? process.env[option.key];
  if (!rawValue || !rawValue.trim()) return;
  loggedEnv.add(option.key);
  log.info(`env: ${option.key}=${formatEnvValue(rawValue, option.redact)} (${option.description})`);
}

export function normalizeZaiEnv(): void {
  if (!process.env.ZAI_API_KEY?.trim() && process.env.Z_AI_API_KEY?.trim()) {
    process.env.ZAI_API_KEY = process.env.Z_AI_API_KEY;
  }
}
```

### 4.2 dotenv 加载

**文件**: `src/infra/dotenv.ts`

```typescript
export function loadDotEnv(opts?: { quiet?: boolean }) {
  const quiet = opts?.quiet ?? true;

  // 首先从当前工作目录加载
  dotenv.config({ quiet });

  // 然后加载全局回退：~/.clawdbot/.env
  const globalEnvPath = path.join(resolveConfigDir(process.env), ".env");
  if (!fs.existsSync(globalEnvPath)) return;

  dotenv.config({ quiet, path: globalEnvPath, override: false });
}
```

### 4.3 Shell 环境回退

**文件**: `src/infra/shell-env.ts`

**从登录 Shell 加载环境变量**:
```typescript
export function loadShellEnvFallback(opts: ShellEnvFallbackOptions): ShellEnvFallbackResult {
  if (!opts.enabled) {
    return { ok: true, applied: [], skippedReason: "disabled" };
  }

  const hasAnyKey = opts.expectedKeys.some((key) => Boolean(opts.env[key]?.trim()));
  if (hasAnyKey) {
    return { ok: true, applied: [], skippedReason: "already-has-keys" };
  }

  const shell = resolveShell(opts.env);

  try {
    stdout = exec(shell, ["-l", "-c", "env -0"], {
      encoding: "buffer",
      timeout: timeoutMs,
      maxBuffer: DEFAULT_MAX_BUFFER_BYTES,
      env: opts.env,
    });
  } catch (err) {
    return { ok: false, error: msg, applied: [] };
  }

  const shellEnv = parseShellEnv(stdout);

  const applied: string[] = [];
  for (const key of opts.expectedKeys) {
    const value = shellEnv.get(key);
    if (value?.trim()) {
      opts.env[key] = value;
      applied.push(key);
    }
  }

  return { ok: true, applied };
}
```

## 5. 文件系统操作

### 5.1 JSON 文件操作

**文件**: `src/infra/json-file.ts`

```typescript
export function loadJsonFile(pathname: string): unknown {
  try {
    if (!fs.existsSync(pathname)) return undefined;
    const raw = fs.readFileSync(pathname, "utf8");
    return JSON.parse(raw) as unknown;
  } catch {
    return undefined;
  }
}

export function saveJsonFile(pathname: string, data: unknown) {
  const dir = path.dirname(pathname);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true, mode: 0o700 });
  }
  fs.writeFileSync(pathname, `${JSON.stringify(data, null, 2)}\n`, "utf8");
  fs.chmodSync(pathname, 0o600);  // 安全权限
}
```

### 5.2 归档文件处理

**文件**: `src/infra/archive.ts`

**支持的归档格式**:
```typescript
export type ArchiveKind = "tar" | "zip";

const TAR_SUFFIXES = [".tgz", ".tar.gz", ".tar"];

export function resolveArchiveKind(filePath: string): ArchiveKind | null {
  const lower = filePath.toLowerCase();
  if (lower.endsWith(".zip")) return "zip";
  if (TAR_SUFFIXES.some((suffix) => lower.endsWith(suffix))) return "tar";
  return null;
}
```

**ZIP 解压（带路径遍历保护）**:
```typescript
async function extractZip(params: { archivePath: string; destDir: string }): Promise<void> {
  const buffer = await fs.readFile(params.archivePath);
  const zip = await JSZip.loadAsync(buffer);

  for (const entry of Object.values(zip.files)) {
    const entryPath = entry.name.replaceAll("\\", "/");
    const outPath = path.resolve(params.destDir, entryPath);

    // 路径遍历保护
    if (!outPath.startsWith(params.destDir)) {
      throw new Error(`zip entry escapes destination: ${entry.name}`);
    }

    await fs.mkdir(path.dirname(outPath), { recursive: true });
    const data = await entry.async("nodebuffer");
    await fs.writeFile(outPath, data);
  }
}
```

## 6. 网络请求工具

### 6.1 Fetch 包装器

**文件**: `src/infra/fetch.ts`

**AbortSignal 兼容性包装**:
```typescript
export function wrapFetchWithAbortSignal(fetchImpl: typeof fetch): typeof fetch {
  const wrapped = ((input: RequestInfo | URL, init?: RequestInit) => {
    const patchedInit = withDuplex(init, input);
    const signal = patchedInit?.signal;

    if (!signal || signal instanceof AbortSignal) {
      return fetchImpl(input, patchedInit);
    }

    // 为非标准 signal 创建 AbortController 桥接
    const controller = new AbortController();
    const onAbort = () => controller.abort();

    if (signal.aborted) {
      controller.abort();
    } else {
      signal.addEventListener("abort", onAbort, { once: true });
    }

    const response = fetchImpl(input, { ...patchedInit, signal: controller.signal });

    void response.finally(() => {
      signal.removeEventListener("abort", onAbort);
    });

    return response;
  }) as FetchWithPreconnect;

  return Object.assign(wrapped, fetchImpl);
}
```

### 6.2 SSRF 防护

**文件**: `src/infra/net/ssrf.ts`

**私有 IP 检测**:
```typescript
function isPrivateIpv4(parts: number[]): boolean {
  const [octet1, octet2] = parts;
  if (octet1 === 0) return true;        // 0.0.0.0/8
  if (octet1 === 10) return true;       // 10.0.0.0/8
  if (octet1 === 127) return true;      // 127.0.0.0/8
  if (octet1 === 169 && octet2 === 254) return true;  // 169.254.0.0/16
  if (octet1 === 172 && octet2 >= 16 && octet2 <= 31) return true;  // 172.16.0.0/12
  if (octet1 === 192 && octet2 === 168) return true;  // 192.168.0.0/16
  if (octet1 === 100 && octet2 >= 64 && octet2 <= 127) return true;  // 100.64.0.0/10
  return false;
}
```

**DNS 固定（防止 DNS 重绑定攻击）**:
```typescript
export async function resolvePinnedHostname(
  hostname: string,
  lookupFn: LookupFn = dnsLookup,
): Promise<PinnedHostname> {
  const normalized = normalizeHostname(hostname);

  // 阻止已知的危险主机名
  if (isBlockedHostname(normalized)) {
    throw new SsrFBlockedError(`Blocked hostname: ${hostname}`);
  }

  // 阻止直接使用私有 IP
  if (isPrivateIpAddress(normalized)) {
    throw new SsrFBlockedError("Blocked: private/internal IP address");
  }

  // 解析所有 IP 地址
  const results = await lookupFn(normalized, { all: true });

  // 检查解析结果中是否包含私有 IP
  for (const entry of results) {
    if (isPrivateIpAddress(entry.address)) {
      throw new SsrFBlockedError("Blocked: resolves to private/internal IP address");
    }
  }

  const addresses = Array.from(new Set(results.map((entry) => entry.address)));

  return {
    hostname: normalized,
    addresses,
    lookup: createPinnedLookup({ hostname: normalized, addresses }),
  };
}
```

### 6.3 重试机制

**文件**: `src/infra/retry.ts`

**指数退避重试**:
```typescript
export async function retryAsync<T>(
  fn: () => Promise<T>,
  attemptsOrOptions: number | RetryOptions = 3,
  initialDelayMs = 300,
): Promise<T> {
  const resolved = resolveRetryConfig(DEFAULT_RETRY_CONFIG, options);
  const maxAttempts = resolved.attempts;
  const minDelayMs = resolved.minDelayMs;
  const maxDelayMs = resolved.maxDelayMs;
  const jitter = resolved.jitter;

  for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {
    try {
      return await fn();
    } catch (err) {
      lastErr = err;
      if (attempt >= maxAttempts || !shouldRetry(err, attempt)) break;

      // 计算延迟：指数退避 + 抖动
      const retryAfterMs = options.retryAfterMs?.(err);
      const baseDelay = hasRetryAfter
        ? Math.max(retryAfterMs, minDelayMs)
        : minDelayMs * 2 ** (attempt - 1);
      let delay = Math.min(baseDelay, maxDelayMs);
      delay = applyJitter(delay, jitter);

      options.onRetry?.({ attempt, maxAttempts, delayMs: delay, err });
      await sleep(delay);
    }
  }

  throw lastErr ?? new Error("Retry failed");
}
```

**抖动算法**:
```typescript
function applyJitter(delayMs: number, jitter: number): number {
  if (jitter <= 0) return delayMs;
  const offset = (Math.random() * 2 - 1) * jitter;  // [-jitter, +jitter]
  return Math.max(0, Math.round(delayMs * (1 + offset)));
}
```

## 7. 高级基础设施功能

### 7.1 网关锁机制

**文件**: `src/infra/gateway-lock.ts`

**防止多实例运行**:
```typescript
export async function acquireGatewayLock(opts: GatewayLockOptions = {}): Promise<GatewayLockHandle | null> {
  const { lockPath, configPath } = resolveGatewayLockPath(env);

  while (Date.now() - startedAt < timeoutMs) {
    try {
      // 尝试独占创建锁文件
      const handle = await fs.open(lockPath, "wx");
      const payload: LockPayload = {
        pid: process.pid,
        createdAt: new Date().toISOString(),
        configPath,
        startTime: platform === "linux" ? readLinuxStartTime(process.pid) : null,
      };
      await handle.writeFile(JSON.stringify(payload), "utf8");

      return {
        lockPath,
        configPath,
        release: async () => {
          await handle.close().catch(() => undefined);
          await fs.rm(lockPath, { force: true });
        },
      };
    } catch (err) {
      // 锁已存在，检查持有者状态
      lastPayload = await readLockPayload(lockPath);
      const ownerStatus = resolveGatewayOwnerStatus(ownerPid, lastPayload, platform);

      if (ownerStatus === "dead") {
        await fs.rm(lockPath, { force: true });
        continue;
      }

      await new Promise((r) => setTimeout(r, pollIntervalMs));
    }
  }

  throw new GatewayLockError(`gateway already running; lock timeout after ${timeoutMs}ms`);
}
```

**Linux 进程验证（防止 PID 重用）**:
```typescript
function readLinuxStartTime(pid: number): number | null {
  try {
    const raw = fsSync.readFileSync(`/proc/${pid}/stat`, "utf8").trim();
    const closeParen = raw.lastIndexOf(")");
    const rest = raw.slice(closeParen + 1).trim();
    const fields = rest.split(/\s+/);
    const startTime = Number.parseInt(fields[19] ?? "", 10);  // 进程启动时间（jiffies）
    return Number.isFinite(startTime) ? startTime : null;
  } catch {
    return null;
  }
}
```

### 7.2 设备身份认证

**文件**: `src/infra/device-identity.ts`

**Ed25519 密钥对生成**:
```typescript
function generateIdentity(): DeviceIdentity {
  const { publicKey, privateKey } = crypto.generateKeyPairSync("ed25519");
  const publicKeyPem = publicKey.export({ type: "spki", format: "pem" }).toString();
  const privateKeyPem = privateKey.export({ type: "pkcs8", format: "pem" }).toString();
  const deviceId = fingerprintPublicKey(publicKeyPem);  // SHA-256 指纹
  return { deviceId, publicKeyPem, privateKeyPem };
}
```

**签名与验证**:
```typescript
export function signDevicePayload(privateKeyPem: string, payload: string): string {
  const key = crypto.createPrivateKey(privateKeyPem);
  const sig = crypto.sign(null, Buffer.from(payload, "utf8"), key);
  return base64UrlEncode(sig);
}

export function verifyDeviceSignature(
  publicKey: string,
  payload: string,
  signatureBase64Url: string,
): boolean {
  try {
    const key = publicKey.includes("BEGIN")
      ? crypto.createPublicKey(publicKey)
      : crypto.createPublicKey({
          key: Buffer.concat([ED25519_SPKI_PREFIX, base64UrlDecode(publicKey)]),
          type: "spki",
          format: "der",
        });
    const sig = base64UrlDecode(signatureBase64Url);
    return crypto.verify(null, Buffer.from(payload, "utf8"), key, sig);
  } catch {
    return false;
  }
}
```

### 7.3 系统事件队列

**文件**: `src/infra/system-events.ts`

**轻量级内存队列（用于前缀到下一个提示）**:
```typescript
export function enqueueSystemEvent(text: string, options: SystemEventOptions) {
  const key = requireSessionKey(options?.sessionKey);
  const entry = queues.get(key) ?? { events: [] };
  entry.events.push({
    text,
    enqueuedAt: Date.now(),
    source: options?.source,
  });
  queues.set(key, entry);
}

export function drainSystemEvents(sessionKey: string): SystemEvent[] {
  const entry = queues.get(sessionKey);
  if (!entry) return [];
  queues.delete(sessionKey);
  return entry.events;
}
```

## 8. 关键文件索引

| 文件 | 说明 |
|------|------|
| `src/logging/logger.ts` | 日志核心 |
| `src/logging/subsystem.ts` | 子系统日志器 |
| `src/infra/errors.ts` | 错误工具函数 |
| `src/infra/unhandled-rejections.ts` | 未处理拒绝处理 |
| `src/infra/env.ts` | 环境变量工具 |
| `src/infra/dotenv.ts` | dotenv 加载 |
| `src/infra/shell-env.ts` | Shell 环境回退 |
| `src/infra/json-file.ts` | JSON 文件操作 |
| `src/infra/archive.ts` | 归档文件处理 |
| `src/infra/fetch.ts` | Fetch 包装器 |
| `src/infra/net/ssrf.ts` | SSRF 防护 |
| `src/infra/retry.ts` | 重试机制 |
| `src/infra/gateway-lock.ts` | 网关锁机制 |
| `src/infra/device-identity.ts` | 设备身份认证 |
| `src/infra/system-events.ts` | 系统事件队列 |

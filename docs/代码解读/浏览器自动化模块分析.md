# 浏览器自动化模块深度分析

## 1. 架构概览

`src/browser/` 目录实现了 Moltbot 的浏览器自动化功能，提供了完整的浏览器控制能力，支持多种浏览器驱动模式和远程控制场景。

### 1.1 核心架构组件

```
src/browser/
├── 核心层 (Core Layer)
│   ├── pw-session.ts          # Playwright 会话管理
│   ├── pw-tools-core.*.ts     # Playwright 工具集 (分模块)
│   ├── chrome.ts              # Chrome 启动与管理
│   └── cdp.ts                 # Chrome DevTools Protocol
│
├── 服务层 (Service Layer)
│   ├── server.ts              # 主服务器
│   ├── server-context.ts      # 上下文管理
│   ├── bridge-server.ts       # 桥接服务器
│   └── extension-relay.ts     # Chrome 扩展中继
│
├── 路由层 (Route Layer)
│   ├── routes/agent.act.ts    # 操作路由
│   ├── routes/agent.snapshot.ts
│   ├── routes/tabs.ts
│   └── routes/basic.ts
│
└── 客户端层 (Client Layer)
    ├── client-actions-core.ts  # 客户端操作
    ├── client-fetch.ts         # HTTP 客户端
    └── config.ts               # 配置解析
```

## 2. Playwright 集成

### 2.1 核心会话管理

**文件**: `pw-session.ts`

```typescript
// 连接的浏览器类型
type ConnectedBrowser = {
  browser: Browser;
  cdpUrl: string;
};

// 状态管理
const pageStates = new WeakMap<Page, PageState>();
const contextStates = new WeakMap<BrowserContext, ContextState>();
const observedContexts = new WeakSet<BrowserContext>();
const observedPages = new WeakSet<Page>();
const roleRefsByTarget = new Map<string, RoleRefsCacheEntry>(); // 角色引用缓存
```

**关键特性**:

1. **持久连接管理**
   - 使用单例模式维护 CDP 连接
   - 支持自动重连（3次重试，递增延迟）
   - 连接超时：5000ms + attempt * 2000ms

```typescript
const connectWithRetry = async (): Promise<ConnectedBrowser> => {
  let lastErr: unknown;
  for (let attempt = 0; attempt < 3; attempt += 1) {
    try {
      const timeout = 5000 + attempt * 2000;
      const wsUrl = await getChromeWebSocketUrl(normalized, timeout).catch(() => null);
      const endpoint = wsUrl ?? normalized;
      const headers = getHeadersWithAuth(endpoint);
      const browser = await chromium.connectOverCDP(endpoint, { timeout, headers });
      // ... 成功处理
    } catch (err) {
      lastErr = err;
      const delay = 250 + attempt * 250;
      await new Promise((r) => setTimeout(r, delay));
    }
  }
  throw lastErr;
};
```

2. **页面状态跟踪**
   - 控制台消息（最多 500 条）
   - 页面错误（最多 200 条）
   - 网络请求（最多 500 条）
   - 角色引用（用于元素定位）

```typescript
page.on("console", (msg: ConsoleMessage) => {
  state.console.push({
    type: msg.type(),
    text: msg.text(),
    timestamp: new Date().toISOString(),
    location: msg.location(),
  });
  if (state.console.length > MAX_CONSOLE_MESSAGES) state.console.shift();
});

page.on("pageerror", (err: Error) => { /* ... */ });
page.on("request", (req: Request) => { /* ... */ });
page.on("response", (resp: Response) => { /* ... */ });
```

3. **角色引用系统**
   - 支持两种模式：`role` 和 `aria`
   - 跨请求缓存（最多 50 个目标）
   - 自动恢复引用

```typescript
export function refLocator(page: Page, ref: string) {
  const normalized = ref.startsWith("@") ? ref.slice(1) :
                     ref.startsWith("ref=") ? ref.slice(4) : ref;

  if (/^e\d+$/.test(normalized)) {
    const state = pageStates.get(page);
    if (state?.roleRefsMode === "aria") {
      return page.locator(`aria-ref=${normalized}`);
    }
    const info = state?.roleRefs?.[normalized];
    if (!info) throw new Error(`Unknown ref "${normalized}"`);

    const locator = info.name
      ? page.getByRole(info.role, { name: info.name, exact: true })
      : page.getByRole(info.role);
    return info.nth !== undefined ? locator.nth(info.nth) : locator;
  }
  return page.locator(`aria-ref=${normalized}`);
}
```

### 2.2 页面操作工具集

**交互操作** (`pw-tools-core.interactions.ts`):

```typescript
export async function clickViaPlaywright(opts: {
  cdpUrl: string;
  targetId?: string;
  ref: string;
  doubleClick?: boolean;
  button?: "left" | "right" | "middle";
  modifiers?: Array<"Alt" | "Control" | "ControlOrMeta" | "Meta" | "Shift">;
  timeoutMs?: number;
}): Promise<void> {
  const page = await getPageForTargetId(opts);
  ensurePageState(page);
  restoreRoleRefsForTarget({ cdpUrl: opts.cdpUrl, targetId: opts.targetId, page });

  const ref = requireRef(opts.ref);
  const locator = refLocator(page, ref);
  const timeout = Math.max(500, Math.min(60_000, Math.floor(opts.timeoutMs ?? 8000)));

  try {
    if (opts.doubleClick) {
      await locator.dblclick({ timeout, button: opts.button, modifiers: opts.modifiers });
    } else {
      await locator.click({ timeout, button: opts.button, modifiers: opts.modifiers });
    }
  } catch (err) {
    throw toAIFriendlyError(err, ref);
  }
}
```

**支持的操作类型**:
- `click` / `dblclick` - 点击操作（支持修饰键）
- `hover` - 悬停
- `drag` - 拖拽
- `type` - 文本输入（支持慢速输入）
- `fill` - 表单填充
- `select` - 下拉选择
- `press` - 按键
- `scrollIntoView` - 滚动到视图
- `evaluate` - JavaScript 执行

**快照与数据提取** (`pw-tools-core.snapshot.ts`):

```typescript
export async function snapshotAiViaPlaywright(opts: {
  cdpUrl: string;
  targetId?: string;
  timeoutMs?: number;
  maxChars?: number;
}): Promise<{ snapshot: string; truncated?: boolean; refs: RoleRefMap }> {
  const page = await getPageForTargetId(opts);
  ensurePageState(page);

  const maybe = page as unknown as WithSnapshotForAI;
  if (!maybe._snapshotForAI) {
    throw new Error("Playwright _snapshotForAI is not available");
  }

  const result = await maybe._snapshotForAI({
    timeout: Math.max(500, Math.min(60_000, Math.floor(opts.timeoutMs ?? 5000))),
    track: "response",
  });

  let snapshot = String(result?.full ?? "");
  const maxChars = opts.maxChars;
  const limit = typeof maxChars === "number" && Number.isFinite(maxChars) && maxChars > 0
    ? Math.floor(maxChars) : undefined;

  let truncated = false;
  if (limit && snapshot.length > limit) {
    snapshot = `${snapshot.slice(0, limit)}\n\n[...TRUNCATED - page too large]`;
    truncated = true;
  }

  const built = buildRoleSnapshotFromAiSnapshot(snapshot);
  storeRoleRefsForTarget({
    page, cdpUrl: opts.cdpUrl, targetId: opts.targetId,
    refs: built.refs, mode: "aria",
  });

  return truncated ? { snapshot, truncated, refs: built.refs } : { snapshot, refs: built.refs };
}
```

**快照类型**:
1. **AI 快照** - 使用 Playwright 的 `_snapshotForAI` API
2. **角色快照** - 基于 ARIA 角色的结构化快照
3. **ARIA 快照** - 完整的可访问性树
4. **截图** - 支持全页和元素截图，带标签

## 3. Chrome 浏览器管理

### 3.1 浏览器启动

**文件**: `chrome.ts`

```typescript
export async function launchClawdChrome(
  resolved: ResolvedBrowserConfig,
  profile: ResolvedBrowserProfile,
): Promise<RunningChrome> {
  if (!profile.cdpIsLoopback) {
    throw new Error(`Profile "${profile.name}" is remote; cannot launch local Chrome.`);
  }
  await ensurePortAvailable(profile.cdpPort);

  const exe = resolveBrowserExecutable(resolved);
  if (!exe) {
    throw new Error("No supported browser found (Chrome/Brave/Edge/Chromium)");
  }

  const userDataDir = resolveClawdUserDataDir(profile.name);
  fs.mkdirSync(userDataDir, { recursive: true });

  // 启动参数
  const args: string[] = [
    `--remote-debugging-port=${profile.cdpPort}`,
    `--user-data-dir=${userDataDir}`,
    "--no-first-run",
    "--no-default-browser-check",
    "--disable-sync",
    "--disable-background-networking",
    "--disable-component-update",
    "--disable-features=Translate,MediaRouter",
    "--disable-session-crashed-bubble",
    "--hide-crash-restore-bubble",
    "--password-store=basic",
  ];

  if (resolved.headless) {
    args.push("--headless=new");
    args.push("--disable-gpu");
  }
  if (resolved.noSandbox) {
    args.push("--no-sandbox");
    args.push("--disable-setuid-sandbox");
  }
  if (process.platform === "linux") {
    args.push("--disable-dev-shm-usage");
  }

  args.push("about:blank");

  return spawn(exe.path, args, {
    stdio: "pipe",
    env: { ...process.env, HOME: os.homedir() },
  });
}
```

**启动流程**:
1. **端口检查** - 确保 CDP 端口可用
2. **可执行文件解析** - 支持 Chrome/Brave/Edge/Chromium
3. **用户数据目录** - `~/.moltbot/browser/{profile}/user-data`
4. **配置文件装饰** - 设置颜色和名称
5. **首次启动引导** - 创建默认配置文件
6. **CDP 就绪等待** - 最多等待 15 秒

### 3.2 CDP 协议实现

**文件**: `cdp.ts`

```typescript
export async function createTargetViaCdp(opts: {
  cdpUrl: string;
  url: string;
}): Promise<{ targetId: string }> {
  const version = await fetchJson<{ webSocketDebuggerUrl?: string }>(
    appendCdpPath(opts.cdpUrl, "/json/version"), 1500
  );
  const wsUrlRaw = String(version?.webSocketDebuggerUrl ?? "").trim();
  const wsUrl = wsUrlRaw ? normalizeCdpWsUrl(wsUrlRaw, opts.cdpUrl) : "";
  if (!wsUrl) throw new Error("CDP /json/version missing webSocketDebuggerUrl");

  return await withCdpSocket(wsUrl, async (send) => {
    const created = await send("Target.createTarget", { url: opts.url }) as {
      targetId?: string;
    };
    const targetId = String(created?.targetId ?? "").trim();
    if (!targetId) throw new Error("CDP Target.createTarget returned no targetId");
    return { targetId };
  });
}
```

**CDP 功能**:
- **截图** - `Page.captureScreenshot`（支持全页）
- **JavaScript 执行** - `Runtime.evaluate`
- **ARIA 树** - `Accessibility.getFullAXTree`
- **DOM 快照** - 自定义 JavaScript 注入
- **元素查询** - `querySelector` 实现

## 4. 浏览器会话管理

### 4.1 多配置文件支持

**文件**: `server-context.ts`

```typescript
function createProfileContext(
  opts: ContextOptions,
  profile: ResolvedBrowserProfile,
): ProfileContext {
  const state = () => {
    const current = opts.getState();
    if (!current) throw new Error("Browser server not started");
    return current;
  };

  const getProfileState = (): ProfileRuntimeState => {
    const current = state();
    let profileState = current.profiles.get(profile.name);
    if (!profileState) {
      profileState = { profile, running: null, lastTargetId: null };
      current.profiles.set(profile.name, profileState);
    }
    return profileState;
  };

  // 标签页列表
  const listTabs = async (): Promise<BrowserTab[]> => {
    // 远程配置文件使用 Playwright 持久连接
    if (!profile.cdpIsLoopback) {
      const mod = await getPwAiModule({ mode: "strict" });
      const listPagesViaPlaywright = mod?.listPagesViaPlaywright;
      if (typeof listPagesViaPlaywright === "function") {
        const pages = await listPagesViaPlaywright({ cdpUrl: profile.cdpUrl });
        return pages.map((p) => ({
          targetId: p.targetId,
          title: p.title,
          url: p.url,
          type: p.type,
        }));
      }
    }

    // 本地配置文件使用 HTTP /json/list
    const raw = await fetchJson<Array<{
      id?: string; title?: string; url?: string;
      webSocketDebuggerUrl?: string; type?: string;
    }>>(appendCdpPath(profile.cdpUrl, "/json/list"));

    return raw.map((t) => ({
      targetId: t.id ?? "",
      title: t.title ?? "",
      url: t.url ?? "",
      wsUrl: normalizeWsUrl(t.webSocketDebuggerUrl, profile.cdpUrl),
      type: t.type,
    })).filter((t) => Boolean(t.targetId));
  };
}
```

**配置文件类型**:

1. **本地配置文件** (`driver: "clawd"`)
   - Moltbot 启动和管理 Chrome 进程
   - 使用本地 CDP 端口（如 18790）
   - 支持无头模式和沙箱禁用

2. **扩展配置文件** (`driver: "extension"`)
   - 通过 Chrome 扩展连接
   - 使用中继服务器（controlPort + 1）
   - 用户手动附加标签页

3. **远程配置文件**
   - 连接到远程 CDP 端点
   - 使用 Playwright 持久连接
   - 支持更长的超时

### 4.2 标签页管理

```typescript
const ensureTabAvailable = async (targetId?: string): Promise<BrowserTab> => {
  await ensureBrowserAvailable();
  const profileState = getProfileState();
  const tabs1 = await listTabs();

  if (tabs1.length === 0) {
    if (profile.driver === "extension") {
      throw new Error(
        `tab not found (no attached Chrome tabs for profile "${profile.name}"). ` +
        "Click the Moltbot Browser Relay toolbar icon on the tab you want to control."
      );
    }
    await openTab("about:blank");
  }

  const tabs = await listTabs();
  const candidates = profile.driver === "extension" || !profile.cdpIsLoopback
    ? tabs : tabs.filter((t) => Boolean(t.wsUrl));

  const resolveById = (raw: string) => {
    const resolved = resolveTargetIdFromTabs(raw, candidates);
    if (!resolved.ok) {
      if (resolved.reason === "ambiguous") return "AMBIGUOUS" as const;
      return null;
    }
    return candidates.find((t) => t.targetId === resolved.targetId) ?? null;
  };

  const pickDefault = () => {
    const last = profileState.lastTargetId?.trim() || "";
    const lastResolved = last ? resolveById(last) : null;
    if (lastResolved && lastResolved !== "AMBIGUOUS") return lastResolved;

    // 优先选择真实页面标签（避免 service worker）
    const page = candidates.find((t) => (t.type ?? "page") === "page");
    return page ?? candidates.at(0) ?? null;
  };

  let chosen = targetId ? resolveById(targetId) : pickDefault();

  if (chosen === "AMBIGUOUS") throw new Error("ambiguous target id prefix");
  if (!chosen) throw new Error("tab not found");

  profileState.lastTargetId = chosen.targetId;
  return chosen;
};
```

## 5. Chrome 扩展中继

### 5.1 中继服务器架构

**文件**: `extension-relay.ts`

```typescript
export async function ensureChromeExtensionRelayServer(opts: {
  cdpUrl: string;
}): Promise<ChromeExtensionRelayServer> {
  const info = parseBaseUrl(opts.cdpUrl);
  if (!isLoopbackHost(info.host)) {
    throw new Error(`extension relay requires loopback cdpUrl host (got ${info.host})`);
  }

  const existing = serversByPort.get(info.port);
  if (existing) return existing;

  let extensionWs: WebSocket | null = null;
  const cdpClients = new Set<WebSocket>();
  const connectedTargets = new Map<string, ConnectedTarget>();

  // 扩展命令转发
  const sendToExtension = async (payload: ExtensionForwardCommandMessage): Promise<unknown> => {
    const ws = extensionWs;
    if (!ws || ws.readyState !== WebSocket.OPEN) {
      throw new Error("Chrome extension not connected");
    }
    ws.send(JSON.stringify(payload));
    return await new Promise<unknown>((resolve, reject) => {
      const timer = setTimeout(() => {
        pendingExtension.delete(payload.id);
        reject(new Error(`extension request timeout: ${payload.params.method}`));
      }, 30_000);
      pendingExtension.set(payload.id, { resolve, reject, timer });
    });
  };

  // CDP 命令路由
  const routeCdpCommand = async (cmd: CdpCommand): Promise<unknown> => {
    switch (cmd.method) {
      case "Browser.getVersion":
        return {
          protocolVersion: "1.3",
          product: "Chrome/Moltbot-Extension-Relay",
          revision: "0",
          userAgent: "Moltbot-Extension-Relay",
          jsVersion: "V8",
        };
      case "Target.setAutoAttach":
      case "Target.setDiscoverTargets":
        return {};
      case "Target.getTargets":
        return {
          targetInfos: Array.from(connectedTargets.values()).map((t) => ({
            ...t.targetInfo, attached: true,
          })),
        };
      default: {
        const id = nextExtensionId++;
        return await sendToExtension({
          id, method: "forwardCDPCommand",
          params: { method: cmd.method, sessionId: cmd.sessionId, params: cmd.params },
        });
      }
    }
  };
}
```

**中继功能**:

1. **双向 WebSocket 通信**
   - `/extension` - 扩展连接端点
   - `/cdp` - CDP 客户端端点

2. **HTTP 端点模拟**
   - `/json/version` - 版本信息
   - `/json/list` - 标签页列表
   - `/json/activate/{targetId}` - 激活标签页
   - `/json/close/{targetId}` - 关闭标签页

3. **目标管理**
   - 自动跟踪附加的标签页
   - 处理 `Target.attachedToTarget` 事件
   - 缓存标签页元数据（URL、标题）

4. **心跳机制**
   - 每 5 秒发送 ping
   - 扩展断开时清理所有客户端

## 6. HTTP 路由层

### 6.1 操作路由

**文件**: `routes/agent.act.ts`

```typescript
app.post("/act", async (req, res) => {
  const profileCtx = resolveProfileContext(req, res, ctx);
  if (!profileCtx) return;

  const body = readBody(req);
  const kindRaw = toStringOrEmpty(body.kind);
  if (!isActKind(kindRaw)) {
    return jsonError(res, 400, "kind is required");
  }

  const kind: ActKind = kindRaw;
  const targetId = toStringOrEmpty(body.targetId) || undefined;

  try {
    const tab = await profileCtx.ensureTabAvailable(targetId);
    const cdpUrl = profileCtx.profile.cdpUrl;
    const pw = await requirePwAi(res, `act:${kind}`);
    if (!pw) return;

    const evaluateEnabled = ctx.state().resolved.evaluateEnabled;

    switch (kind) {
      case "click": {
        const ref = toStringOrEmpty(body.ref);
        if (!ref) return jsonError(res, 400, "ref is required");
        const doubleClick = toBoolean(body.doubleClick) ?? false;
        const timeoutMs = toNumber(body.timeoutMs);
        const button = parseClickButton(toStringOrEmpty(body.button) || "");
        const modifiers = parseClickModifiers(toStringArray(body.modifiers) ?? []);

        await pw.clickViaPlaywright({
          cdpUrl, targetId: tab.targetId, ref, doubleClick,
          button, modifiers: modifiers.modifiers, timeoutMs,
        });
        return res.json({ ok: true, targetId: tab.targetId, url: tab.url });
      }
      // ... 其他操作类型
    }
  } catch (err) {
    handleRouteError(ctx, res, err);
  }
});
```

**路由分类**:

1. **基础路由** (`routes/basic.ts`)
   - `GET /` - 健康检查
   - `GET /status` - 服务器状态
   - `GET /profiles` - 配置文件列表

2. **标签页路由** (`routes/tabs.ts`)
   - `GET /tabs` - 列出标签页
   - `POST /tabs/open` - 打开新标签页
   - `POST /tabs/focus` - 聚焦标签页
   - `POST /tabs/close` - 关闭标签页

3. **Agent 路由** (`routes/agent.ts`)
   - `POST /act` - 执行操作
   - `POST /snapshot` - 获取快照
   - `POST /screenshot` - 截图
   - `POST /navigate` - 导航
   - `POST /hooks/*` - 钩子（文件选择器、对话框）
   - `POST /wait/download` - 等待下载
   - `POST /storage/*` - 存储操作
   - `POST /trace/*` - 跟踪操作

## 7. 关键设计模式

### 7.1 状态管理模式

```typescript
// WeakMap 用于页面状态（自动垃圾回收）
const pageStates = new WeakMap<Page, PageState>();

// Map 用于配置文件状态（手动管理）
const profiles = new Map<string, ProfileRuntimeState>();

// WeakSet 用于观察标记
const observedPages = new WeakSet<Page>();
```

### 7.2 连接池模式

```typescript
// 单例 CDP 连接
let cached: ConnectedBrowser | null = null;
let connecting: Promise<ConnectedBrowser> | null = null;

// 连接复用
if (cached?.cdpUrl === normalized) return cached;
if (connecting) return await connecting;
```

### 7.3 容错与重试

```typescript
// 3 次重试，递增延迟
for (let attempt = 0; attempt < 3; attempt += 1) {
  try {
    const timeout = 5000 + attempt * 2000;
    // ... 尝试连接
  } catch (err) {
    lastErr = err;
    const delay = 250 + attempt * 250;
    await new Promise((r) => setTimeout(r, delay));
  }
}
```

### 7.4 资源清理

```typescript
// 页面关闭时自动清理
page.on("close", () => {
  pageStates.delete(page);
  observedPages.delete(page);
});

// 浏览器断开时清理
browser.on("disconnected", () => {
  if (cached?.browser === browser) cached = null;
});
```

## 8. 关键文件索引

| 文件 | 说明 |
|------|------|
| `pw-session.ts` | Playwright 会话管理 |
| `pw-tools-core.interactions.ts` | 交互操作工具 |
| `pw-tools-core.snapshot.ts` | 快照工具 |
| `chrome.ts` | Chrome 启动与管理 |
| `cdp.ts` | Chrome DevTools Protocol |
| `server.ts` | 主服务器 |
| `server-context.ts` | 上下文管理 |
| `extension-relay.ts` | Chrome 扩展中继 |
| `routes/agent.act.ts` | 操作路由 |
| `client-actions-core.ts` | 客户端操作 |
| `config.ts` | 配置解析 |

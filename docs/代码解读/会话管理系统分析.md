# 会话管理系统深度分析

## 1. 会话存储机制

### 1.1 存储路径和格式

**核心路径解析文件**: `src/config/sessions/paths.ts`

**存储结构**:
```
~/.clawdbot/agents/<agentId>/sessions/
├── sessions.json              # 会话元数据存储 (JSON)
├── <sessionId>.jsonl          # 会话转录文件 (JSONL)
└── <sessionId>-topic-<topicId>.jsonl  # 线程会话转录
```

**关键函数**:
```typescript
// 解析会话转录目录
resolveSessionTranscriptsDir() → ~/.clawdbot/agents/main/sessions/

// 解析会话存储路径
resolveDefaultSessionStorePath(agentId) → ~/.clawdbot/agents/<agentId>/sessions/sessions.json

// 解析会话转录文件路径
resolveSessionTranscriptPath(sessionId, agentId, topicId) →
  ~/.clawdbot/agents/<agentId>/sessions/<sessionId>.jsonl
```

### 1.2 会话数据结构

**核心类型定义**: `src/config/sessions/types.ts`

```typescript
export type SessionEntry = {
  // 会话标识
  sessionId: string;
  updatedAt: number;
  sessionFile?: string;

  // 会话状态
  systemSent?: boolean;
  abortedLastRun?: boolean;

  // 会话配置
  chatType?: SessionChatType;  // "direct" | "group" | "channel"
  thinkingLevel?: string;
  verboseLevel?: string;
  reasoningLevel?: string;
  elevatedLevel?: string;
  ttsAuto?: TtsAutoMode;

  // 执行配置
  execHost?: string;
  execSecurity?: string;
  execAsk?: string;
  execNode?: string;

  // 模型覆盖
  providerOverride?: string;
  modelOverride?: string;
  authProfileOverride?: string;
  authProfileOverrideSource?: "auto" | "user";
  authProfileOverrideCompactionCount?: number;

  // Token 使用统计
  inputTokens?: number;
  outputTokens?: number;
  totalTokens?: number;
  contextTokens?: number;
  compactionCount?: number;

  // 内存刷新
  memoryFlushAt?: number;
  memoryFlushCompactionCount?: number;

  // 群组相关
  groupActivation?: "mention" | "always";
  groupActivationNeedsSystemIntro?: boolean;
  groupId?: string;
  subject?: string;
  groupChannel?: string;
  space?: string;

  // 消息队列
  queueMode?: "steer" | "followup" | "collect" | "steer-backlog" | "steer+backlog" | "queue" | "interrupt";
  queueDebounceMs?: number;
  queueCap?: number;
  queueDrop?: "old" | "new" | "summarize";

  // 发送策略
  sendPolicy?: "allow" | "deny";
  responseUsage?: "on" | "off" | "tokens" | "full";

  // 路由信息
  channel?: string;
  label?: string;
  displayName?: string;
  origin?: SessionOrigin;
  deliveryContext?: DeliveryContext;
  lastChannel?: SessionChannelId;
  lastTo?: string;
  lastAccountId?: string;
  lastThreadId?: string | number;

  // 子会话关系
  spawnedBy?: string;  // 父会话 key

  // 技能快照
  skillsSnapshot?: SessionSkillSnapshot;
  systemPromptReport?: SessionSystemPromptReport;

  // CLI 会话
  cliSessionIds?: Record<string, string>;
  claudeCliSessionId?: string;

  // 心跳
  lastHeartbeatText?: string;
  lastHeartbeatSentAt?: number;
};
```

### 1.3 持久化策略

**核心存储文件**: `src/config/sessions/store.ts`

**缓存机制**:
- **TTL**: 45 秒 (可通过 `CLAWDBOT_SESSION_CACHE_TTL_MS` 环境变量配置)
- **缓存键**: 存储文件路径
- **缓存验证**: 基于文件 mtime 检测变更
- **缓存失效**: 写入时自动失效

**文件锁机制**:
```typescript
// 使用文件锁保证并发安全
withSessionStoreLock(storePath, async () => {
  // 原子性读写操作
  const store = loadSessionStore(storePath, { skipCache: true });
  // 修改 store
  await saveSessionStoreUnlocked(storePath, store);
});
```

**关键函数**:
- `loadSessionStore(storePath)`: 加载会话存储 (支持缓存)
- `saveSessionStore(storePath, store)`: 保存会话存储 (带锁)
- `updateSessionStore(storePath, mutator)`: 原子性更新
- `updateSessionStoreEntry(params)`: 更新单个会话条目

**原子性写入** (非 Windows):
```typescript
// 使用临时文件 + rename 保证原子性
const tmp = `${storePath}.${process.pid}.${crypto.randomUUID()}.tmp`;
await fs.promises.writeFile(tmp, json, { mode: 0o600 });
await fs.promises.rename(tmp, storePath);
```

## 2. 会话生命周期

### 2.1 会话创建流程

**核心初始化文件**: `src/auto-reply/reply/session.ts`

**会话创建触发条件**:
1. 新用户首次发送消息
2. 用户发送重置触发器 (`/new`, `/reset`)
3. 会话过期 (基于重置策略)

**初始化流程** (`initSessionState`):
```typescript
1. 解析会话 Key (resolveSessionKey)
   - 全局模式: "global"
   - 群组模式: "agent:<agentId>:<channel>:group:<groupId>"
   - 直接模式: "agent:<agentId>:main"

2. 检查重置触发器
   - 匹配 /new, /reset 等命令
   - 提取剥离后的消息体

3. 评估会话新鲜度
   - 检查 daily reset (每日重置)
   - 检查 idle timeout (空闲超时)

4. 创建或恢复会话
   - 新会话: 生成新 sessionId (UUID)
   - 旧会话: 保留 sessionId 和配置

5. 处理线程会话
   - 支持从父会话 fork
   - 创建分支会话文件

6. 持久化会话状态
   - 更新 sessions.json
   - 创建 .jsonl 转录文件
```

### 2.2 会话恢复

**SessionManager 初始化**: `src/agents/pi-embedded-runner/session-manager-init.ts`

```typescript
// 准备 SessionManager 以确保首次用户消息被持久化
prepareSessionManagerForRun({
  sessionManager,
  sessionFile,
  hadSessionFile,
  sessionId,
  cwd
});
```

**问题修复**:
- pi-coding-agent 的 SessionManager 在文件存在但无 assistant 消息时会标记 `flushed=true`
- 导致首次用户消息不被持久化
- 解决方案: 重置文件并清空 `fileEntries`

### 2.3 会话销毁

**会话清理时机**:
1. 用户主动重置 (`/new`)
2. 会话过期 (基于重置策略)
3. 子代理会话完成 (cleanup: "delete")

**清理操作**:
- 重置 `compactionCount` 为 0
- 清除 `memoryFlushAt` 和 `memoryFlushCompactionCount`
- 保留会话配置覆盖 (modelOverride, thinkingLevel 等)

## 3. 会话 Key 生成和管理

### 3.1 会话 Key 格式

**核心文件**: `src/routing/session-key.ts`

**格式规范**:
```
agent:<agentId>:<rest>

示例:
- 主会话: agent:main:main
- 群组会话: agent:main:telegram:group:123456
- 频道会话: agent:main:discord:channel:general
- 子代理会话: agent:main:subagent:<uuid>
- 线程会话: agent:main:main:thread:<threadId>
```

### 3.2 会话 Key 解析

**解析函数**: `src/sessions/session-key-utils.ts`

```typescript
// 解析 agent session key
parseAgentSessionKey(sessionKey) → { agentId, rest }

// 判断是否为子代理会话
isSubagentSessionKey(sessionKey) → boolean

// 判断是否为 ACP 会话
isAcpSessionKey(sessionKey) → boolean

// 解析线程父会话 key
resolveThreadParentSessionKey(sessionKey) → string | null
```

### 3.3 会话 Key 构建

```typescript
// 构建主会话 key
buildAgentMainSessionKey({ agentId, mainKey })
  → "agent:<agentId>:<mainKey>"

// 构建点对点会话 key
buildAgentPeerSessionKey({
  agentId,
  channel,
  peerKind,
  peerId,
  dmScope
})
  → "agent:<agentId>:<channel>:<peerKind>:<peerId>"

// 构建群组历史 key
buildGroupHistoryKey({ channel, accountId, peerKind, peerId })
  → "<channel>:<accountId>:<peerKind>:<peerId>"
```

## 4. 上下文窗口管理

### 4.1 上下文大小限制

**默认配置**: `src/agents/defaults.ts`

```typescript
export const DEFAULT_CONTEXT_TOKENS = 200_000;  // 200K tokens
```

**上下文窗口解析**: `src/agents/context-window-guard.ts`

**优先级顺序**:
1. 模型自身的 `contextWindow` 属性
2. 配置文件中的 `models.providers[provider].models[].contextWindow`
3. 配置文件中的 `agents.defaults.contextTokens`
4. 默认值 `DEFAULT_CONTEXT_TOKENS` (200K)

**守卫机制**:
```typescript
// 硬性最小值: 16K tokens
CONTEXT_WINDOW_HARD_MIN_TOKENS = 16_000

// 警告阈值: 32K tokens
CONTEXT_WINDOW_WARN_BELOW_TOKENS = 32_000

evaluateContextWindowGuard({
  info: { tokens, source },
  warnBelowTokens,
  hardMinTokens
}) → {
  tokens,
  source,
  shouldWarn,   // tokens < 32K
  shouldBlock   // tokens < 16K
}
```

### 4.2 上下文修剪策略

**核心文件**: `src/agents/compaction.ts`

**修剪算法**:

```typescript
// 1. 按 Token 份额分割消息
splitMessagesByTokenShare(messages, parts = 2)
  → AgentMessage[][]

// 2. 按最大 Token 数分块
chunkMessagesByMaxTokens(messages, maxTokens)
  → AgentMessage[][]

// 3. 自适应分块比例
computeAdaptiveChunkRatio(messages, contextWindow)
  → number  // BASE_CHUNK_RATIO (0.4) 到 MIN_CHUNK_RATIO (0.15)

// 4. 修剪历史以适应上下文份额
pruneHistoryForContextShare({
  messages,
  maxContextTokens,
  maxHistoryShare = 0.5,  // 历史最多占 50% 上下文
  parts = 2
}) → {
  messages,              // 保留的消息
  droppedMessagesList,   // 丢弃的消息
  droppedChunks,
  droppedMessages,
  droppedTokens,
  keptTokens,
  budgetTokens
}
```

**修剪策略**:
- 默认历史占用上下文的 **50%**
- 从最旧的消息开始丢弃
- 按 Token 份额分块丢弃 (避免丢弃单个大消息)
- 保留最近的消息以维持对话连贯性

### 4.3 Token 计算

**Token 估算**:
```typescript
import { estimateTokens } from "@mariozechner/pi-coding-agent";

// 估算单条消息的 token 数
estimateTokens(message) → number

// 估算消息列表的总 token 数
estimateMessagesTokens(messages) → number
```

**安全边际**:
```typescript
SAFETY_MARGIN = 1.2  // 20% 缓冲以应对估算不准确
```

## 5. 会话压缩机制

### 5.1 压缩触发条件

**触发场景**:
1. 上下文窗口即将溢出
2. 用户主动执行 `/compact` 命令
3. 内存刷新 (memory flush) 后自动压缩

**压缩检测**:
```typescript
// 检查是否为压缩失败错误
isCompactionFailureError(error) → boolean

// 检查是否为上下文溢出错误
isContextOverflowError(error) → boolean
```

### 5.2 压缩算法和策略

**核心压缩文件**: `src/agents/pi-embedded-runner/compact.ts`

**压缩流程** (`compactEmbeddedPiSession`):

```typescript
1. 获取会话锁 (acquireSessionWriteLock)
   - 防止并发压缩冲突

2. 预热会话文件 (prewarmSessionFile)
   - 读取文件到 OS 页缓存

3. 打开 SessionManager
   - 加载会话历史

4. 清理和验证历史
   - sanitizeSessionHistory: 清理无效消息
   - validateGeminiTurns: 验证 Gemini 消息格式
   - validateAnthropicTurns: 验证 Anthropic 消息格式
   - limitHistoryTurns: 限制历史轮数

5. 执行压缩 (session.compact)
   - 调用 pi-coding-agent 的压缩逻辑
   - 生成摘要并删除旧消息

6. 估算压缩后 Token 数
   - 遍历剩余消息估算 Token

7. 返回压缩结果
   - summary: 压缩摘要
   - firstKeptEntryId: 保留的第一条消息 ID
   - tokensBefore: 压缩前 Token 数
   - tokensAfter: 压缩后 Token 数
```

**分阶段摘要** (`summarizeInStages`):

```typescript
// 处理超大会话的分阶段摘要
summarizeInStages({
  messages,
  model,
  apiKey,
  signal,
  reserveTokens,
  maxChunkTokens,
  contextWindow,
  customInstructions,
  previousSummary,
  parts = 2,
  minMessagesForSplit = 4
}) → string

流程:
1. 按 Token 份额分割消息 (splitMessagesByTokenShare)
2. 对每个分块生成部分摘要
3. 合并部分摘要为最终摘要
```

**回退策略** (`summarizeWithFallback`):

```typescript
// 处理超大消息的回退摘要
summarizeWithFallback({...}) → string

流程:
1. 尝试完整摘要
2. 失败时: 分离超大消息和小消息
3. 仅摘要小消息
4. 为超大消息添加占位符注释
5. 最终回退: 返回消息统计信息
```

### 5.3 压缩后的恢复

**压缩计数跟踪**:
```typescript
sessionEntry.compactionCount = (sessionEntry.compactionCount ?? 0) + 1;
```

**压缩后状态**:
- 旧消息被删除
- 保留压缩摘要作为上下文
- 保留最近的消息
- 更新 `compactionCount`
- 更新 `contextTokens`

**压缩失败处理**:
```typescript
// 重试机制
if (isCompactionFailureError(error)) {
  // 重置会话并重试
  await resetSession();
  return retry();
}
```

## 6. 多会话支持

### 6.1 主会话与子会话

**主会话**:
- Key 格式: `agent:<agentId>:main`
- 用于用户直接交互
- 持久化配置和状态

**子会话 (Subagent)**:
- Key 格式: `agent:<agentId>:subagent:<uuid>`
- 用于后台任务执行
- 隔离的上下文和工具权限

**子会话创建**: `src/agents/tools/sessions-spawn-tool.ts`

```typescript
createSessionsSpawnTool({
  agentSessionKey,
  agentChannel,
  agentAccountId,
  agentTo,
  agentThreadId,
  agentGroupId,
  agentGroupChannel,
  agentGroupSpace,
  sandboxed,
  requesterAgentIdOverride
})

参数:
- task: 子代理任务描述
- label: 可选标签
- agentId: 目标 agent ID
- model: 模型覆盖
- thinking: 思考级别
- runTimeoutSeconds: 运行超时
- cleanup: "delete" | "keep"

返回:
- status: "accepted" | "forbidden" | "error"
- childSessionKey: 子会话 key
- runId: 运行 ID
- modelApplied: 是否应用了模型覆盖
- warning: 警告信息
```

**子会话限制**:
- 子会话不能再创建子会话 (防止递归)
- 需要在父 agent 配置中允许跨 agent 调用
- 继承父会话的工具策略

### 6.2 Agent 会话隔离

**Agent 目录结构**:
```
~/.clawdbot/agents/
  ├── main/
  │   ├── sessions/
  │   │   ├── sessions.json
  │   │   ├── <sessionId>.jsonl
  │   │   └── ...
  │   └── ...
  ├── agent-a/
  │   ├── sessions/
  │   │   └── ...
  │   └── ...
  └── agent-b/
      ├── sessions/
      │   └── ...
      └── ...
```

**隔离机制**:
- 每个 agent 有独立的会话存储
- 会话 key 包含 agent ID
- 工具权限基于 agent 配置
- 沙箱环境基于 agent 配置

### 6.3 会话切换机制

**会话切换**:
```typescript
// 通过 sessionKey 参数切换会话
callGateway({
  method: "agent",
  params: {
    message: "...",
    sessionKey: "agent:main:subagent:xxx",
    ...
  }
});
```

**会话路由**:
- 基于 `sessionKey` 解析目标 agent
- 加载对应 agent 的配置和会话状态
- 应用 agent 特定的工具策略和沙箱设置

## 7. 会话写锁机制

**核心文件**: `src/agents/session-write-lock.ts`

**锁机制**:
```typescript
acquireSessionWriteLock({
  sessionFile,
  timeoutMs = 10_000,
  staleMs = 30 * 60 * 1000  // 30 分钟
}) → { release: () => Promise<void> }

特性:
- 基于文件锁 (wx 模式)
- 支持重入 (同一进程多次获取)
- 自动清理过期锁
- 进程退出时自动释放
- 支持信号处理 (SIGINT, SIGTERM, SIGQUIT, SIGABRT)
```

**锁文件格式**:
```json
{
  "pid": 12345,
  "createdAt": "2026-01-30T10:00:00.000Z"
}
```

**过期锁清理**:
- 检查锁文件的 `createdAt` 时间
- 检查持有锁的进程是否存活
- 自动删除过期或死进程的锁

## 8. 核心数据流

### 8.1 消息接收到会话更新

```
1. 接收消息 (auto-reply/reply/session.ts)
   ↓
2. 解析会话 Key (resolveSessionKey)
   ↓
3. 加载会话存储 (loadSessionStore)
   ↓
4. 检查重置触发器和新鲜度
   ↓
5. 创建或恢复会话 (initSessionState)
   ↓
6. 更新会话元数据 (updateSessionStore)
   ↓
7. 执行 Agent 运行
   ↓
8. 追加消息到转录文件 (SessionManager.appendMessage)
   ↓
9. 更新 Token 统计和压缩计数
```

### 8.2 压缩流程

```
1. 检测上下文溢出
   ↓
2. 获取会话锁 (acquireSessionWriteLock)
   ↓
3. 加载 SessionManager
   ↓
4. 清理和验证历史消息
   ↓
5. 执行压缩 (session.compact)
   - 生成摘要
   - 删除旧消息
   - 保留最近消息
   ↓
6. 估算压缩后 Token 数
   ↓
7. 更新会话元数据 (compactionCount++)
   ↓
8. 释放会话锁
```

### 8.3 子会话创建和通知

```
1. 主会话调用 sessions_spawn 工具
   ↓
2. 验证权限 (allowAgents 配置)
   ↓
3. 生成子会话 Key (agent:<agentId>:subagent:<uuid>)
   ↓
4. 应用模型覆盖 (sessions.patch)
   ↓
5. 构建子代理系统提示
   ↓
6. 调用 Gateway agent 方法
   - deliver: false (不发送消息)
   - lane: AGENT_LANE_SUBAGENT
   - spawnedBy: 父会话 key
   ↓
7. 注册子代理运行 (registerSubagentRun)
   ↓
8. 子代理完成后通知父会话
```

## 9. 性能优化

### 9.1 缓存策略

**会话存储缓存**:
- TTL: 45 秒
- 基于文件 mtime 验证
- 写入时自动失效

**SessionManager 缓存**:
- TTL: 45 秒
- 预热机制 (prewarmSessionFile)
- 读取 4KB 到 OS 页缓存

### 9.2 并发控制

**文件锁**:
- 防止并发写入冲突
- 支持重入锁
- 自动清理过期锁

**Lane 队列**:
- 会话级别队列 (session lane)
- 全局队列 (global lane)
- 防止死锁

### 9.3 内存管理

**上下文修剪**:
- 历史最多占 50% 上下文
- 自适应分块比例
- 优先保留最近消息

**压缩策略**:
- 分阶段摘要 (处理超大会话)
- 回退策略 (处理超大消息)
- 增量压缩

## 10. 关键文件索引

| 文件 | 说明 |
|------|------|
| `src/config/sessions/paths.ts` | 路径解析 |
| `src/config/sessions/types.ts` | 数据结构 |
| `src/config/sessions/store.ts` | 存储操作 |
| `src/config/sessions/metadata.ts` | 元数据管理 |
| `src/config/sessions/transcript.ts` | 转录管理 |
| `src/config/sessions/session-key.ts` | Key 生成 |
| `src/config/sessions/reset.ts` | 重置策略 |
| `src/auto-reply/reply/session.ts` | 会话初始化 |
| `src/agents/pi-embedded-runner/session-manager-init.ts` | SessionManager 准备 |
| `src/agents/pi-embedded-runner/session-manager-cache.ts` | 会话缓存 |
| `src/agents/compaction.ts` | 压缩算法 |
| `src/agents/context-window-guard.ts` | 上下文守卫 |
| `src/agents/pi-embedded-runner/compact.ts` | 压缩执行 |
| `src/routing/session-key.ts` | Key 构建 |
| `src/sessions/session-key-utils.ts` | Key 解析 |
| `src/agents/tools/sessions-spawn-tool.ts` | 子会话创建 |
| `src/agents/session-write-lock.ts` | 会话写锁 |

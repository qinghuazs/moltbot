# 定时任务系统深度分析

## 1. 定时任务的架构设计

### 1.1 核心架构概览

`src/cron/` 目录实现了一个完整的定时任务调度系统。架构采用分层设计：

```
src/cron/
├── types.ts                    # 核心类型定义
├── service.ts                  # 服务入口（CronService 类）
├── service/                    # 服务实现层
│   ├── state.ts               # 状态管理
│   ├── ops.ts                 # 操作实现（CRUD）
│   ├── timer.ts               # 定时器管理与任务执行
│   ├── jobs.ts                # 任务逻辑处理
│   ├── store.ts               # 存储加载与持久化
│   ├── locked.ts              # 并发锁机制
│   └── normalize.ts           # 数据规范化
├── isolated-agent/             # 隔离 Agent 执行
│   ├── run.ts                 # 隔离任务运行器
│   ├── session.ts             # 会话管理
│   ├── delivery-target.ts     # 投递目标解析
│   └── helpers.ts             # 辅助函数
├── schedule.ts                 # 调度计算
├── parse.ts                    # 时间解析
├── store.ts                    # 存储路径与 I/O
├── run-log.ts                  # 运行日志
├── normalize.ts                # 输入规范化
└── payload-migration.ts        # 向后兼容迁移
```

### 1.2 核心类型系统

**文件**: `src/cron/types.ts`

#### 调度类型
```typescript
export type CronSchedule =
  | { kind: "at"; atMs: number }              // 一次性任务
  | { kind: "every"; everyMs: number; anchorMs?: number }  // 固定间隔
  | { kind: "cron"; expr: string; tz?: string };           // Cron 表达式
```

#### Payload 类型
```typescript
export type CronPayload =
  | { kind: "systemEvent"; text: string }     // 主会话：系统事件
  | {
      kind: "agentTurn";                      // 隔离会话：Agent 回合
      message: string;
      model?: string;                         // 模型覆盖
      thinking?: string;                      // 思考级别
      timeoutSeconds?: number;
      allowUnsafeExternalContent?: boolean;
      deliver?: boolean;                      // 是否投递
      channel?: CronMessageChannel;           // 投递渠道
      to?: string;                            // 投递目标
      bestEffortDeliver?: boolean;            // 容错投递
    };
```

#### 任务结构
```typescript
export type CronJob = {
  id: string;                    // UUID
  agentId?: string;              // 绑定的 Agent ID
  name: string;
  description?: string;
  enabled: boolean;
  deleteAfterRun?: boolean;      // 一次性任务自动删除
  createdAtMs: number;
  updatedAtMs: number;
  schedule: CronSchedule;
  sessionTarget: CronSessionTarget;  // "main" | "isolated"
  wakeMode: CronWakeMode;            // "next-heartbeat" | "now"
  payload: CronPayload;
  isolation?: CronIsolation;         // 隔离配置
  state: CronJobState;               // 运行状态
};
```

### 1.3 服务层设计

**文件**: `src/cron/service.ts`

`CronService` 类是外部接口，采用依赖注入模式：

```typescript
export class CronService {
  private readonly state;
  constructor(deps: CronServiceDeps) {
    this.state = createCronServiceState(deps);
  }
```

核心方法：
- `start()` - 启动调度器
- `stop()` - 停止调度器
- `list()` - 列出任务
- `add()` - 添加任务
- `update()` - 更新任务
- `remove()` - 删除任务
- `run()` - 手动运行任务
- `wake()` - 立即唤醒心跳

## 2. Cron 表达式的解析

### 2.1 调度计算核心

**文件**: `src/cron/schedule.ts`

使用 `croner` 库进行 Cron 表达式解析：

```typescript
import { Cron } from "croner";
```

#### 下次运行时间计算

```typescript
export function computeNextRunAtMs(schedule: CronSchedule, nowMs: number): number | undefined {
  if (schedule.kind === "at") {
    // 一次性任务：只在未来时间运行一次
    return schedule.atMs > nowMs ? schedule.atMs : undefined;
  }

  if (schedule.kind === "every") {
    // 固定间隔：基于锚点时间计算下次运行
    const everyMs = Math.max(1, Math.floor(schedule.everyMs));
    const anchor = Math.max(0, Math.floor(schedule.anchorMs ?? nowMs));
    if (nowMs < anchor) return anchor;
    const elapsed = nowMs - anchor;
    const steps = Math.max(1, Math.floor((elapsed + everyMs - 1) / everyMs));
    return anchor + steps * everyMs;
  }

  // Cron 表达式：使用 croner 库解析
  const expr = schedule.expr.trim();
  if (!expr) return undefined;
  const cron = new Cron(expr, {
    timezone: schedule.tz?.trim() || undefined,
    catch: false,
  });
  const next = cron.nextRun(new Date(nowMs));
  return next ? next.getTime() : undefined;
}
```

### 2.2 时间解析

**文件**: `src/cron/parse.ts`

支持多种时间格式：

```typescript
export function parseAbsoluteTimeMs(input: string): number | null {
  const raw = input.trim();
  if (!raw) return null;

  // 纯数字：直接作为毫秒时间戳
  if (/^\d+$/.test(raw)) {
    const n = Number(raw);
    if (Number.isFinite(n) && n > 0) return Math.floor(n);
  }

  // ISO 8601 格式：自动补全时区为 UTC
  const parsed = Date.parse(normalizeUtcIso(raw));
  return Number.isFinite(parsed) ? parsed : null;
}
```

ISO 时间规范化：
- `2025-12-13` → `2025-12-13T00:00:00Z`
- `2025-12-13T10:00:00` → `2025-12-13T10:00:00Z`

## 3. 任务的调度和执行

### 3.1 定时器管理

**文件**: `src/cron/service/timer.ts`

#### 定时器武装

```typescript
export function armTimer(state: CronServiceState) {
  if (state.timer) clearTimeout(state.timer);
  state.timer = null;
  if (!state.deps.cronEnabled) return;

  const nextAt = nextWakeAtMs(state);  // 计算最近的任务时间
  if (!nextAt) return;

  const delay = Math.max(nextAt - state.deps.nowMs(), 0);
  // 防止 TimeoutOverflowWarning（Node.js 限制 2^31-1 ms）
  const clampedDelay = Math.min(delay, MAX_TIMEOUT_MS);

  state.timer = setTimeout(() => {
    void onTimer(state).catch((err) => {
      state.deps.log.error({ err: String(err) }, "cron: timer tick failed");
    });
  }, clampedDelay);
  state.timer.unref?.();  // 不阻止进程退出
}
```

#### 定时器触发

```typescript
export async function onTimer(state: CronServiceState) {
  if (state.running) return;  // 防止重入
  state.running = true;
  try {
    await locked(state, async () => {
      await ensureLoaded(state);    // 加载任务
      await runDueJobs(state);      // 执行到期任务
      await persist(state);         // 持久化状态
      armTimer(state);              // 重新武装定时器
    });
  } finally {
    state.running = false;
  }
}
```

### 3.2 任务执行流程

**文件**: `src/cron/service/timer.ts`

#### 查找到期任务

```typescript
export async function runDueJobs(state: CronServiceState) {
  if (!state.store) return;
  const now = state.deps.nowMs();
  const due = state.store.jobs.filter((j) => {
    if (!j.enabled) return false;
    if (typeof j.state.runningAtMs === "number") return false;  // 跳过运行中
    const next = j.state.nextRunAtMs;
    return typeof next === "number" && now >= next;
  });
  for (const job of due) {
    await executeJob(state, job, now, { forced: false });
  }
}
```

#### 任务执行核心

```typescript
export async function executeJob(
  state: CronServiceState,
  job: CronJob,
  nowMs: number,
  opts: { forced: boolean },
) {
  const startedAt = state.deps.nowMs();
  job.state.runningAtMs = startedAt;
  job.state.lastError = undefined;
  emit(state, { jobId: job.id, action: "started", runAtMs: startedAt });

  const finish = async (status, err?, summary?, outputText?) => {
    // 更新状态
    job.state.runningAtMs = undefined;
    job.state.lastRunAtMs = startedAt;
    job.state.lastStatus = status;
    job.state.lastDurationMs = Math.max(0, endedAt - startedAt);

    // 一次性任务处理
    if (job.schedule.kind === "at" && status === "ok") {
      if (job.deleteAfterRun === true) {
        // 删除任务
        state.store.jobs = state.store.jobs.filter((j) => j.id !== job.id);
        deleted = true;
      } else {
        // 禁用任务
        job.enabled = false;
      }
    }

    // 隔离任务：发送摘要到主会话
    if (job.sessionTarget === "isolated") {
      const prefix = job.isolation?.postToMainPrefix?.trim() || "Cron";
      const mode = job.isolation?.postToMainMode ?? "summary";

      let body = (summary ?? err ?? status).trim();
      if (mode === "full") {
        const maxChars = job.isolation?.postToMainMaxChars ?? 8000;
        const fullText = (outputText ?? "").trim();
        if (fullText) {
          body = fullText.length > maxChars ? `${fullText.slice(0, maxChars)}…` : fullText;
        }
      }

      state.deps.enqueueSystemEvent(`${prefix}: ${body}`, { agentId: job.agentId });
      if (job.wakeMode === "now") {
        state.deps.requestHeartbeatNow({ reason: `cron:${job.id}:post` });
      }
    }
  };

  try {
    if (job.sessionTarget === "main") {
      // 主会话任务：入队系统事件
      const text = resolveJobPayloadTextForMain(job);
      if (!text) {
        await finish("skipped", "main job requires non-empty systemEvent text");
        return;
      }
      state.deps.enqueueSystemEvent(text, { agentId: job.agentId });

      if (job.wakeMode === "now" && state.deps.runHeartbeatOnce) {
        // 立即运行心跳并等待完成
        const heartbeatResult = await state.deps.runHeartbeatOnce({ reason: `cron:${job.id}` });
        // ... 处理心跳结果
      } else {
        // 下次心跳运行
        state.deps.requestHeartbeatNow({ reason: `cron:${job.id}` });
        await finish("ok", undefined, text);
      }
      return;
    }

    // 隔离任务：运行独立 Agent 回合
    const res = await state.deps.runIsolatedAgentJob({ job, message: job.payload.message });
    if (res.status === "ok") await finish("ok", undefined, res.summary, res.outputText);
    else if (res.status === "skipped") await finish("skipped", undefined, res.summary, res.outputText);
    else await finish("error", res.error ?? "cron job failed", res.summary, res.outputText);
  } catch (err) {
    await finish("error", String(err));
  }
}
```

### 3.3 隔离 Agent 执行

**文件**: `src/cron/isolated-agent/run.ts`

隔离任务在独立会话中运行：

```typescript
export async function runCronIsolatedAgentTurn(params: {
  cfg: MoltbotConfig;
  deps: CliDeps;
  job: CronJob;
  message: string;
  sessionKey: string;
  agentId?: string;
  lane?: string;
}): Promise<RunCronAgentTurnResult> {
  // 1. 解析 Agent 配置
  const agentId = resolveAgentId(params);
  const agentCfg = resolveAgentConfig(params);

  // 2. 构建会话 Key
  const baseSessionKey = `cron:${params.job.id}`;
  const agentSessionKey = buildAgentMainSessionKey({ agentId, mainKey: baseSessionKey });

  // 3. 解析模型与思考级别
  // 优先级：任务覆盖 > Hook 默认 > Agent 默认
  let provider = resolvedDefault.provider;
  let model = resolvedDefault.model;
  if (params.job.payload.kind === "agentTurn" && params.job.payload.model) {
    // 任务级别模型覆盖
    const resolvedOverride = resolveAllowedModelRef({ ... });
    provider = resolvedOverride.ref.provider;
    model = resolvedOverride.ref.model;
  }

  // 4. 创建隔离会话
  const cronSession = resolveCronSession({
    cfg: params.cfg,
    sessionKey: agentSessionKey,
    agentId,
    nowMs: now,
  });

  // 5. 安全包装外部内容
  const isExternalHook = isExternalHookSession(baseSessionKey);
  if (isExternalHook && !allowUnsafeExternalContent) {
    // 检测可疑模式
    const suspiciousPatterns = detectSuspiciousPatterns(params.message);
    // 包装为安全提示
    commandBody = buildSafeExternalPrompt({ content: params.message, ... });
  }

  // 6. 运行 Agent
  const fallbackResult = await runWithModelFallback({
    cfg: cfgWithAgentDefaults,
    provider,
    model,
    run: (providerOverride, modelOverride) => {
      if (isCliProvider(providerOverride, cfgWithAgentDefaults)) {
        return runCliAgent({ ... });
      }
      return runEmbeddedPiAgent({ ... });
    },
  });

  // 7. 处理投递
  if (deliveryRequested && !skipHeartbeatDelivery && !skipMessagingToolDelivery) {
    if (!resolvedDelivery.to) {
      if (!bestEffortDeliver) {
        return { status: "error", error: "Cron delivery requires a recipient" };
      }
      return { status: "skipped", summary: "Delivery skipped" };
    }
    await deliverOutboundPayloads({ ... });
  }

  return { status: "ok", summary, outputText };
}
```

## 4. 任务的持久化和恢复

### 4.1 存储结构

**文件**: `src/cron/store.ts`

#### 存储路径

```typescript
export const DEFAULT_CRON_DIR = path.join(CONFIG_DIR, "cron");
export const DEFAULT_CRON_STORE_PATH = path.join(DEFAULT_CRON_DIR, "jobs.json");

export function resolveCronStorePath(storePath?: string) {
  if (storePath?.trim()) {
    const raw = storePath.trim();
    if (raw.startsWith("~")) return path.resolve(raw.replace("~", os.homedir()));
    return path.resolve(raw);
  }
  return DEFAULT_CRON_STORE_PATH;  // ~/.clawdbot/cron/jobs.json
}
```

#### 加载任务

```typescript
export async function loadCronStore(storePath: string): Promise<CronStoreFile> {
  try {
    const raw = await fs.promises.readFile(storePath, "utf-8");
    const parsed = JSON5.parse(raw) as Partial<CronStoreFile> | null;
    const jobs = Array.isArray(parsed?.jobs) ? (parsed?.jobs as never[]) : [];
    return {
      version: 1,
      jobs: jobs.filter(Boolean) as never as CronStoreFile["jobs"],
    };
  } catch {
    return { version: 1, jobs: [] };  // 文件不存在时返回空
  }
}
```

#### 保存任务

```typescript
export async function saveCronStore(storePath: string, store: CronStoreFile) {
  await fs.promises.mkdir(path.dirname(storePath), { recursive: true });

  // 原子写入：先写临时文件，再重命名
  const tmp = `${storePath}.${process.pid}.${Math.random().toString(16).slice(2)}.tmp`;
  const json = JSON.stringify(store, null, 2);
  await fs.promises.writeFile(tmp, json, "utf-8");
  await fs.promises.rename(tmp, storePath);

  // 备份（尽力而为）
  try {
    await fs.promises.copyFile(storePath, `${storePath}.bak`);
  } catch { /* best-effort */ }
}
```

### 4.2 缓存与加载

**文件**: `src/cron/service/store.ts`

#### 内存缓存

```typescript
const storeCache = new Map<string, { version: 1; jobs: CronJob[] }>();
```

#### 懒加载机制

```typescript
export async function ensureLoaded(state: CronServiceState) {
  if (state.store) return;  // 已加载

  // 检查缓存
  const cached = storeCache.get(state.deps.storePath);
  if (cached) {
    state.store = cached;
    return;
  }

  // 从磁盘加载
  const loaded = await loadCronStore(state.deps.storePath);
  const jobs = (loaded.jobs ?? []) as unknown as Array<Record<string, unknown>>;

  // 数据迁移与规范化
  let mutated = false;
  for (const raw of jobs) {
    // 补全缺失的 name
    const nameRaw = raw.name;
    if (typeof nameRaw !== "string" || nameRaw.trim().length === 0) {
      raw.name = inferLegacyName({ schedule: raw.schedule, payload: raw.payload });
      mutated = true;
    }

    // 规范化 description
    const desc = normalizeOptionalText(raw.description);
    if (raw.description !== desc) {
      raw.description = desc;
      mutated = true;
    }

    // 迁移旧版 payload（provider → channel）
    const payload = raw.payload;
    if (payload && typeof payload === "object" && !Array.isArray(payload)) {
      if (migrateLegacyCronPayload(payload as Record<string, unknown>)) {
        mutated = true;
      }
    }
  }

  state.store = { version: 1, jobs: jobs as unknown as CronJob[] };
  storeCache.set(state.deps.storePath, state.store);

  if (mutated) await persist(state);  // 保存迁移后的数据
}
```

### 4.3 运行日志

**文件**: `src/cron/run-log.ts`

#### 日志路径

```typescript
export function resolveCronRunLogPath(params: { storePath: string; jobId: string }) {
  const storePath = path.resolve(params.storePath);
  const dir = path.dirname(storePath);
  return path.join(dir, "runs", `${params.jobId}.jsonl`);  // ~/.clawdbot/cron/runs/<jobId>.jsonl
}
```

#### 追加日志

```typescript
export async function appendCronRunLog(
  filePath: string,
  entry: CronRunLogEntry,
  opts?: { maxBytes?: number; keepLines?: number },
) {
  const resolved = path.resolve(filePath);

  // 串行化写入（防止并发冲突）
  const prev = writesByPath.get(resolved) ?? Promise.resolve();
  const next = prev
    .catch(() => undefined)
    .then(async () => {
      await fs.mkdir(path.dirname(resolved), { recursive: true });
      await fs.appendFile(resolved, `${JSON.stringify(entry)}\n`, "utf-8");

      // 自动裁剪（默认 2MB / 2000 行）
      await pruneIfNeeded(resolved, {
        maxBytes: opts?.maxBytes ?? 2_000_000,
        keepLines: opts?.keepLines ?? 2_000,
      });
    });
  writesByPath.set(resolved, next);
  await next;
}
```

## 5. 与 Agent 的集成

### 5.1 Gateway 集成

**文件**: `src/gateway/server-cron.ts`

#### 服务构建

```typescript
export function buildGatewayCronService(params: {
  cfg: ReturnType<typeof loadConfig>;
  deps: CliDeps;
  broadcast: (event: string, payload: unknown, opts?: { dropIfSlow?: boolean }) => void;
}): GatewayCronState {
  const cronLogger = getChildLogger({ module: "cron" });
  const storePath = resolveCronStorePath(params.cfg.cron?.store);
  const cronEnabled = process.env.CLAWDBOT_SKIP_CRON !== "1" && params.cfg.cron?.enabled !== false;

  const cron = new CronService({
    storePath,
    cronEnabled,

    // 系统事件入队
    enqueueSystemEvent: (text, opts) => {
      const { agentId, cfg: runtimeConfig } = resolveCronAgent(opts?.agentId);
      const sessionKey = resolveAgentMainSessionKey({ cfg: runtimeConfig, agentId });
      enqueueSystemEvent(text, { sessionKey });
    },

    // 心跳唤醒
    requestHeartbeatNow,

    // 心跳运行（主会话任务）
    runHeartbeatOnce: async (opts) => {
      const runtimeConfig = loadConfig();
      return await runHeartbeatOnce({
        cfg: runtimeConfig,
        reason: opts?.reason,
        deps: { ...params.deps, runtime: defaultRuntime },
      });
    },

    // 隔离任务运行
    runIsolatedAgentJob: async ({ job, message }) => {
      const { agentId, cfg: runtimeConfig } = resolveCronAgent(job.agentId);
      return await runCronIsolatedAgentTurn({
        cfg: runtimeConfig,
        deps: params.deps,
        job,
        message,
        agentId,
        sessionKey: `cron:${job.id}`,
        lane: "cron",
      });
    },

    log: getChildLogger({ module: "cron", storePath }),

    // 事件广播
    onEvent: (evt) => {
      params.broadcast("cron", evt, { dropIfSlow: true });

      // 记录运行日志
      if (evt.action === "finished") {
        const logPath = resolveCronRunLogPath({ storePath, jobId: evt.jobId });
        void appendCronRunLog(logPath, {
          ts: Date.now(),
          jobId: evt.jobId,
          action: "finished",
          status: evt.status,
          error: evt.error,
          summary: evt.summary,
          runAtMs: evt.runAtMs,
          durationMs: evt.durationMs,
          nextRunAtMs: evt.nextRunAtMs,
        }).catch((err) => {
          cronLogger.warn({ err: String(err), logPath }, "cron: run log append failed");
        });
      }
    },
  });

  return { cron, storePath, cronEnabled };
}
```

### 5.2 并发控制

**文件**: `src/cron/service/locked.ts`

#### 锁机制

```typescript
const storeLocks = new Map<string, Promise<void>>();

export async function locked<T>(state: CronServiceState, fn: () => Promise<T>): Promise<T> {
  const storePath = state.deps.storePath;

  // 等待两个链：状态操作链 + 存储路径锁链
  const storeOp = storeLocks.get(storePath) ?? Promise.resolve();
  const next = Promise.all([resolveChain(state.op), resolveChain(storeOp)]).then(fn);

  // 保持链存活（即使操作失败）
  const keepAlive = resolveChain(next);
  state.op = keepAlive;
  storeLocks.set(storePath, keepAlive);

  return (await next) as T;
}
```

**关键设计**:
1. **状态锁**: `state.op` 确保同一服务实例的操作串行化
2. **存储锁**: `storeLocks` 确保多个服务实例共享同一存储时不冲突
3. **容错**: 操作失败不会破坏锁链

### 5.3 配置系统

**文件**: `src/config/types.cron.ts`

```typescript
export type CronConfig = {
  enabled?: boolean;              // 默认 true
  store?: string;                 // 默认 ~/.clawdbot/cron/jobs.json
  maxConcurrentRuns?: number;     // 默认 1（未实现）
};
```

## 6. CLI 命令参考

### 6.1 任务管理命令

```bash
# 列出所有任务
moltbot cron list

# 添加任务
moltbot cron add --name "Daily check" --cron "0 9 * * *" --message "Check status"

# 添加一次性任务
moltbot cron add --name "Reminder" --at "2025-12-25T10:00:00Z" --message "Merry Christmas!"

# 添加固定间隔任务
moltbot cron add --name "Hourly ping" --every 1h --message "Ping"

# 隔离会话任务
moltbot cron add --name "Ops check" --cron "0 */4 * * *" \
  --session isolated --message "Check ops queue" --agent ops

# 修改任务
moltbot cron edit <jobId> --agent ops
moltbot cron edit <jobId> --clear-agent

# 手动运行（调试）
moltbot cron run <jobId> --force

# 运行历史
moltbot cron runs --id <jobId> --limit 50
```

## 7. 关键文件索引

| 文件 | 说明 |
|------|------|
| `src/cron/types.ts` | 核心类型定义 |
| `src/cron/service.ts` | 服务入口 |
| `src/cron/service/timer.ts` | 定时器管理与任务执行 |
| `src/cron/service/store.ts` | 存储加载与持久化 |
| `src/cron/service/locked.ts` | 并发锁机制 |
| `src/cron/schedule.ts` | 调度计算 |
| `src/cron/parse.ts` | 时间解析 |
| `src/cron/store.ts` | 存储路径与 I/O |
| `src/cron/run-log.ts` | 运行日志 |
| `src/cron/isolated-agent/run.ts` | 隔离任务运行器 |
| `src/gateway/server-cron.ts` | Gateway 集成 |
